
CATEGORY: style
NOTE: unnecessary use of $key in foreach
\Framework\TestCase.php:1722:26 (routine dataToString)
Variable $key is not used.
        /**
         * @param  mixed  $data
         * @return string
         * @since  Method available since Release 3.2.1
         */
        protected function dataToString($data)
        {
            $result = array();
    
            set_error_handler(function ($errno, $errstr, $errfile, $errline) {
                throw new ErrorException($errstr, $errno, $errno, $errfile, $errline);
            }, E_WARNING);
    
>>>>        foreach ($data as $key => $_data) {
                try {
                    // Detect array-recursions by using count
                    // http://php.net/manual/en/function.count.php
                    $iRecursiveCheck = count($_data, COUNT_RECURSIVE);
    
                    if (is_array($_data)) {
                        $result[] = 'array(' . $this->dataToString($_data) . ')';
                    } elseif (is_object($_data)) {
                        $object = new ReflectionObject($_data);
    
                        if ($object->hasMethod('__toString')) {
                            $result[] = (string) $_data;
                        } else {
                            $result[] = get_class($_data);
                        }
                    } elseif (is_resource($_data)) {
                        $result[] = '<resource>';
                    } else {
                        $result[] = var_export($_data, true);
                    }
                } catch (ErrorException $e) {
                    $result[] = '*RECURSION*';
                }
            }
    
            restore_error_handler();
    
            return join(', ', $result);
        }

CATEGORY: style
NOTE: the fact that count generates notice is probably the aim of invoking it, 
but do we have to same the result to an unused variable?
\Framework\TestCase.php:1726:16 (routine dataToString)
Variable $iRecursiveCheck is not used.
        /**
         * @param  mixed  $data
         * @return string
         * @since  Method available since Release 3.2.1
         */
        protected function dataToString($data)
        {
            $result = array();
    
            set_error_handler(function ($errno, $errstr, $errfile, $errline) {
                throw new ErrorException($errstr, $errno, $errno, $errfile, $errline);
            }, E_WARNING);
    
            foreach ($data as $key => $_data) {
                try {
                    // Detect array-recursions by using count
                    // http://php.net/manual/en/function.count.php
>>>>                $iRecursiveCheck = count($_data, COUNT_RECURSIVE);
    
                    if (is_array($_data)) {
                        $result[] = 'array(' . $this->dataToString($_data) . ')';
                    } elseif (is_object($_data)) {
                        $object = new ReflectionObject($_data);
    
                        if ($object->hasMethod('__toString')) {
                            $result[] = (string) $_data;
                        } else {
                            $result[] = get_class($_data);
                        }
                    } elseif (is_resource($_data)) {
                        $result[] = '<resource>';
                    } else {
                        $result[] = var_export($_data, true);
                    }
                } catch (ErrorException $e) {
                    $result[] = '*RECURSION*';
                }
            }
    
            restore_error_handler();
    
            return join(', ', $result);
        }

CATEGORY: false positive
NOTE: allow conversions from object, string, phparray to boolean, it is a common pattern
\Extensions\PhptTestCase.php:148:17 (routine run)
Expression strncasecmp('skip', ltrim($jobResult['stdout']), 4) is expected to be of type String|PhpArray|Object, but it is of type Integer.
         * Runs a test and collects its result in a TestResult instance.
         *
         * @param  PHPUnit_Framework_TestResult $result
         * @return PHPUnit_Framework_TestResult
         */
        public function run(PHPUnit_Framework_TestResult $result = null)
        {
            $sections = $this->parse();
            $code     = $this->render($sections['FILE']);
    
            if ($result === null) {
                $result = new PHPUnit_Framework_TestResult;
            }
    
            $php  = PHPUnit_Util_PHP::factory();
            $skip = false;
            $time = 0;
    
            $result->startTest($this);
    
            if (isset($sections['SKIPIF'])) {
                $jobResult = $php->runJob($sections['SKIPIF'], $this->settings);
    
>>>>            if (!strncasecmp('skip', ltrim($jobResult['stdout']), 4)) {
                    if (preg_match('/^\s*skip\s*(.+)\s*/i', $jobResult['stdout'], $message)) {
                        $message = substr($message[1], 2);
                    } else {
                        $message = '';
                    }
    
                    $result->addFailure($this, new PHPUnit_Framework_SkippedTestError($message), 0);
    
                    $skip = true;
                }
            }
    
            if (!$skip) {
                PHP_Timer::start();
                $jobResult = $php->runJob($code, $this->settings);
                $time = PHP_Timer::stop();
    
                if (isset($sections['EXPECT'])) {
                    $assertion = 'assertEquals';
                    $expected  = preg_replace('/\r\n/', "\n", trim($sections['EXPECT']));
                } else {
                    $assertion = 'assertStringMatchesFormat';
                    $expected  = trim($sections['EXPECTF']);
                }
    
                try {
                    PHPUnit_Framework_Assert::$assertion($expected, trim($jobResult['stdout']));
                } catch (PHPUnit_Framework_AssertionFailedError $e) {
                    $result->addFailure($this, $e, $time);
                } catch (Exception $e) {
                    $result->addError($this, $e, $time);
                }
            }
    
            $result->endTest($this, $time);
    
            return $result;
        }

CATEGORY: error
NOTE: In standard DOM implementation DOMElement is the only subclass of DOMNode. However, anyone can 
create another subclass of DOMNode and add it as a child of another DOMElement in which case 
this function would throw an exception because of being invoked with wrong parameter type
\Framework\Assert.php:1861:14 (routine assertEqualXMLStructure)
The routine PHP.Core.AST.DirectStMtdCall expects type DOMElement as its parameter number 0, but the expression is of type DOMNode.
         * @param boolean    $checkAttributes
         * @param string     $message
         * @author Mattis Stordalen Flister <mattis@xait.no>
         * @since  Method available since Release 3.3.0
         */
        public static function assertEqualXMLStructure(DOMElement $expectedElement, DOMElement $actualElement, $checkAttributes = false, $message = '')
        {
            self::assertEquals(
              $expectedElement->tagName,
              $actualElement->tagName,
              $message
            );
    
            if ($checkAttributes) {
                self::assertEquals(
                  $expectedElement->attributes->length,
                  $actualElement->attributes->length,
                  sprintf(
                    '%s%sNumber of attributes on node "%s" does not match',
                    $message,
                    !empty($message) ? "\n" : '',
                    $expectedElement->tagName
                  )
                );
    
                for ($i = 0 ; $i < $expectedElement->attributes->length; $i++) {
                    $expectedAttribute = $expectedElement->attributes->item($i);
                    $actualAttribute   = $actualElement->attributes->getNamedItem(
                      $expectedAttribute->name
                    );
    
                    if (!$actualAttribute) {
                        self::fail(
                          sprintf(
                            '%s%sCould not find attribute "%s" on node "%s"',
                            $message,
                            !empty($message) ? "\n" : '',
                            $expectedAttribute->name,
                            $expectedElement->tagName
                          )
                        );
                    }
                }
            }
    
            PHPUnit_Util_XML::removeCharacterDataNodes($expectedElement);
            PHPUnit_Util_XML::removeCharacterDataNodes($actualElement);
    
            self::assertEquals(
              $expectedElement->childNodes->length,
              $actualElement->childNodes->length,
              sprintf(
                '%s%sNumber of child nodes of "%s" differs',
                $message,
                !empty($message) ? "\n" : '',
                $expectedElement->tagName
              )
            );
    
            for ($i = 0; $i < $expectedElement->childNodes->length; $i++) {
                self::assertEqualXMLStructure(
>>>>              $expectedElement->childNodes->item($i),
                  $actualElement->childNodes->item($i),
                  $checkAttributes,
                  $message
                );
            }
        }

NOTE: the same as previous
\Framework\Assert.php:1862:14 (routine assertEqualXMLStructure)
The routine PHP.Core.AST.DirectStMtdCall expects type DOMElement as its parameter number 1, but the expression is of type DOMNode.
>>> CODE REMOVED

CATEGORY: documentation
CATEGORY: missing false
\Util\XML.php:544:23 (routine findNodes)
The routine is expected to return type PhpArray|Null, the the expression false is of type False.
        /**
         * Parse out the options from the tag using DOM object tree.
         *
         * @param  DOMDocument $dom
         * @param  array       $options
         * @param  boolean     $isHtml
         * @return array
         * @since  Method available since Release 3.3.0
         * @author Mike Naberezny <mike@maintainable.com>
         * @author Derek DeVries <derek@maintainable.com>
         * @author Tobias Schlitt <toby@php.net>
         */
        public static function findNodes(DOMDocument $dom, array $options, $isHtml = true)
        {
            $valid = array(
              'id', 'class', 'tag', 'content', 'attributes', 'parent',
              'child', 'ancestor', 'descendant', 'children', 'adjacent-sibling'
            );
    
            $filtered = array();
            $options  = self::assertValidKeys($options, $valid);
    
            // find the element by id
            if ($options['id']) {
                $options['attributes']['id'] = $options['id'];
            }
    
            if ($options['class']) {
                $options['attributes']['class'] = $options['class'];
            }
    
            // find the element by a tag type
            if ($options['tag']) {
                if ($isHtml) {
                    $elements = self::getElementsByCaseInsensitiveTagName(
                      $dom, $options['tag']
                    );
                } else {
                    $elements = $dom->getElementsByTagName($options['tag']);
                }
    
                foreach ($elements as $element) {
                    $nodes[] = $element;
                }
    
                if (empty($nodes)) {
>>>>                return false;
                }
            }
    
            // no tag selected, get them all
            else {
                $tags = array(
                  'a', 'abbr', 'acronym', 'address', 'area', 'b', 'base', 'bdo',
                  'big', 'blockquote', 'body', 'br', 'button', 'caption', 'cite',
                  'code', 'col', 'colgroup', 'dd', 'del', 'div', 'dfn', 'dl',
                  'dt', 'em', 'fieldset', 'form', 'frame', 'frameset', 'h1', 'h2',
                  'h3', 'h4', 'h5', 'h6', 'head', 'hr', 'html', 'i', 'iframe',
                  'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link',
                  'map', 'meta', 'noframes', 'noscript', 'object', 'ol', 'optgroup',
                  'option', 'p', 'param', 'pre', 'q', 'samp', 'script', 'select',
                  'small', 'span', 'strong', 'style', 'sub', 'sup', 'table',
                  'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'title',
                  'tr', 'tt', 'ul', 'var',
                  // HTML5
                  'article', 'aside', 'audio', 'bdi', 'canvas', 'command',
                  'datalist', 'details', 'dialog', 'embed', 'figure', 'figcaption',
                  'footer', 'header', 'hgroup', 'keygen', 'mark', 'meter', 'nav',
                  'output', 'progress', 'ruby', 'rt', 'rp', 'track', 'section',
                  'source', 'summary', 'time', 'video', 'wbr'
                );
    
                foreach ($tags as $tag) {
                    if ($isHtml) {
                        $elements = self::getElementsByCaseInsensitiveTagName(
                          $dom, $tag
                        );
                    } else {
                        $elements = $dom->getElementsByTagName($tag);
                    }
    
                    foreach ($elements as $element) {
                        $nodes[] = $element;
                    }
                }
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by attributes
            if ($options['attributes']) {
                foreach ($nodes as $node) {
                    $invalid = false;
    
                    foreach ($options['attributes'] as $name => $value) {
                        // match by regexp if like "regexp:/foo/i"
                        if (preg_match('/^regexp\s*:\s*(.*)/i', $value, $matches)) {
                            if (!preg_match($matches[1], $node->getAttribute($name))) {
                                $invalid = true;
                            }
                        }
    
                        // class can match only a part
                        else if ($name == 'class') {
                            // split to individual classes
                            $findClasses = explode(
                              ' ', preg_replace("/\s+/", " ", $value)
                            );
    
                            $allClasses = explode(
                              ' ',
                              preg_replace("/\s+/", " ", $node->getAttribute($name))
                            );
    
                            // make sure each class given is in the actual node
                            foreach ($findClasses as $findClass) {
                                if (!in_array($findClass, $allClasses)) {
                                    $invalid = true;
                                }
                            }
                        }
    
                        // match by exact string
                        else {
                            if ($node->getAttribute($name) != $value) {
                                $invalid = true;
                            }
                        }
                    }
    
                    // if every attribute given matched
                    if (!$invalid) {
                        $filtered[] = $node;
                    }
                }
    
                $nodes    = $filtered;
                $filtered = array();
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by content
            if ($options['content'] !== null) {
                foreach ($nodes as $node) {
                    $invalid = false;
    
                    // match by regexp if like "regexp:/foo/i"
                    if (preg_match('/^regexp\s*:\s*(.*)/i', $options['content'], $matches)) {
                        if (!preg_match($matches[1], self::getNodeText($node))) {
                            $invalid = true;
                        }
                    }
    
                    // match empty string
                    else if ($options['content'] === '') {
                        if (self::getNodeText($node) !== '') {
                            $invalid = true;
                        }
                    }
    
                    // match by exact string
                    else if (strstr(self::getNodeText($node), $options['content']) === false) {
                        $invalid = true;
                    }
    
                    if (!$invalid) {
                        $filtered[] = $node;
                    }
                }
    
                $nodes    = $filtered;
                $filtered = array();
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by parent node
            if ($options['parent']) {
                $parentNodes = self::findNodes($dom, $options['parent'], $isHtml);
                $parentNode  = isset($parentNodes[0]) ? $parentNodes[0] : null;
    
                foreach ($nodes as $node) {
                    if ($parentNode !== $node->parentNode) {
                        continue;
                    }
    
                    $filtered[] = $node;
                }
    
                $nodes    = $filtered;
                $filtered = array();
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by child node
            if ($options['child']) {
                $childNodes = self::findNodes($dom, $options['child'], $isHtml);
                $childNodes = !empty($childNodes) ? $childNodes : array();
    
                foreach ($nodes as $node) {
                    foreach ($node->childNodes as $child) {
                        foreach ($childNodes as $childNode) {
                            if ($childNode === $child) {
                                $filtered[] = $node;
                            }
                        }
                    }
                }
    
                $nodes    = $filtered;
                $filtered = array();
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by adjacent-sibling
            if ($options['adjacent-sibling']) {
                $adjacentSiblingNodes = self::findNodes($dom, $options['adjacent-sibling'], $isHtml);
                $adjacentSiblingNodes = !empty($adjacentSiblingNodes) ? $adjacentSiblingNodes : array();
    
                foreach ($nodes as $node) {
                    $sibling = $node;
    
                    while ($sibling = $sibling->nextSibling) {
                        if ($sibling->nodeType !== XML_ELEMENT_NODE) {
                            continue;
                        }
    
                        foreach ($adjacentSiblingNodes as $adjacentSiblingNode) {
                            if ($sibling === $adjacentSiblingNode) {
                                $filtered[] = $node;
                                break;
                            }
                        }
    
                        break;
                    }
                }
    
                $nodes    = $filtered;
                $filtered = array();
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by ancestor
            if ($options['ancestor']) {
                $ancestorNodes = self::findNodes($dom, $options['ancestor'], $isHtml);
                $ancestorNode  = isset($ancestorNodes[0]) ? $ancestorNodes[0] : null;
    
                foreach ($nodes as $node) {
                    $parent = $node->parentNode;
    
                    while ($parent && $parent->nodeType != XML_HTML_DOCUMENT_NODE) {
                        if ($parent === $ancestorNode) {
                            $filtered[] = $node;
                        }
    
                        $parent = $parent->parentNode;
                    }
                }
    
                $nodes    = $filtered;
                $filtered = array();
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by descendant
            if ($options['descendant']) {
                $descendantNodes = self::findNodes($dom, $options['descendant'], $isHtml);
                $descendantNodes = !empty($descendantNodes) ? $descendantNodes : array();
    
                foreach ($nodes as $node) {
                    foreach (self::getDescendants($node) as $descendant) {
                        foreach ($descendantNodes as $descendantNode) {
                            if ($descendantNode === $descendant) {
                                $filtered[] = $node;
                            }
                        }
                    }
                }
    
                $nodes    = $filtered;
                $filtered = array();
    
                if (empty($nodes)) {
                    return false;
                }
            }
    
            // filter by children
            if ($options['children']) {
                $validChild   = array('count', 'greater_than', 'less_than', 'only');
                $childOptions = self::assertValidKeys(
                                  $options['children'], $validChild
                                );
    
                foreach ($nodes as $node) {
                    $childNodes = $node->childNodes;
    
                    foreach ($childNodes as $childNode) {
                        if ($childNode->nodeType !== XML_CDATA_SECTION_NODE &&
                            $childNode->nodeType !== XML_TEXT_NODE) {
                            $children[] = $childNode;
                        }
                    }
    
                    // we must have children to pass this filter
                    if (!empty($children)) {
                        // exact count of children
                        if ($childOptions['count'] !== null) {
                            if (count($children) !== $childOptions['count']) {
                                break;
                            }
                        }
    
                        // range count of children
                        else if ($childOptions['less_than']    !== null &&
                                $childOptions['greater_than'] !== null) {
                            if (count($children) >= $childOptions['less_than'] ||
                                count($children) <= $childOptions['greater_than']) {
                                break;
                            }
                        }
    
                        // less than a given count
                        else if ($childOptions['less_than'] !== null) {
                            if (count($children) >= $childOptions['less_than']) {
                                break;
                            }
                        }
    
                        // more than a given count
                        else if ($childOptions['greater_than'] !== null) {
                            if (count($children) <= $childOptions['greater_than']) {
                                break;
                            }
                        }
    
                        // match each child against a specific tag
                        if ($childOptions['only']) {
                            $onlyNodes = self::findNodes(
                              $dom, $childOptions['only'], $isHtml
                            );
    
                            // try to match each child to one of the 'only' nodes
                            foreach ($children as $child) {
                                $matched = false;
    
                                foreach ($onlyNodes as $onlyNode) {
                                    if ($onlyNode === $child) {
                                        $matched = true;
                                    }
                                }
    
                                if (!$matched) {
                                    break 2;
                                }
                            }
                        }
    
                        $filtered[] = $node;
                    }
                }
    
                $nodes = $filtered;
    
                if (empty($nodes)) {
                    return;
                }
            }
    
            // return the first node that matches all criteria
            return !empty($nodes) ? $nodes : array();
        }
        
NOTE: the same as previous
\Util\XML.php:585:23 (routine findNodes)
\Util\XML.php:640:23 (routine findNodes)
\Util\XML.php:677:23 (routine findNodes)
\Util\XML.php:698:23 (routine findNodes)
\Util\XML.php:721:23 (routine findNodes)
\Util\XML.php:753:23 (routine findNodes)
\Util\XML.php:778:23 (routine findNodes)
\Util\XML.php:801:23 (routine findNodes)

CATEGORY: documentation
NOTE: They count on $count being not only number, but boolean and array too, 
however, this is not stated in the documentation.
\Framework\Assert.php:1960:23 (routine assertSelectEquals)
Expression $count is of scalar type and cannot be subscribed to with [] operator.
        /**
         * assertSelectEquals("#binder .name", "Chuck", true,  $xml);  // any?
         * assertSelectEquals("#binder .name", "Chuck", false, $xml);  // none?
         *
         * @param array                 $selector
         * @param string                $content
         * @param integer|boolean|array $count
         * @param mixed                 $actual
         * @param string                $message
         * @param boolean               $isHtml
         * @since  Method available since Release 3.3.0
         * @author Mike Naberezny <mike@maintainable.com>
         * @author Derek DeVries <derek@maintainable.com>
         */
        public static function assertSelectEquals($selector, $content, $count, $actual, $message = '', $isHtml = true)
        {
            $tags = PHPUnit_Util_XML::cssSelect(
              $selector, $content, $actual, $isHtml
            );
    
            // assert specific number of elements
            if (is_numeric($count)) {
                $counted = $tags ? count($tags) : 0;
                self::assertEquals($count, $counted, $message);
            }
    
            // assert any elements exist if true, assert no elements exist if false
            else if (is_bool($count)) {
                $any = count($tags) > 0 && $tags[0] instanceof DOMNode;
    
                if ($count) {
                    self::assertTrue($any, $message);
                } else {
                    self::assertFalse($any, $message);
                }
            }
    
            // check for range number of elements
            else if (is_array($count) &&
>>>>                (isset($count['>']) || isset($count['<']) ||
                    isset($count['>=']) || isset($count['<=']))) {
                $counted = $tags ? count($tags) : 0;
    
                if (isset($count['>'])) {
                    self::assertTrue($counted > $count['>'], $message);
                }
    
                if (isset($count['>='])) {
                    self::assertTrue($counted >= $count['>='], $message);
                }
    
                if (isset($count['<'])) {
                    self::assertTrue($counted < $count['<'], $message);
                }
    
                if (isset($count['<='])) {
                    self::assertTrue($counted <= $count['<='], $message);
                }
            } else {
                throw new PHPUnit_Framework_Exception;
            }
        }
        
NOTE: the same as previous
\Framework\Assert.php:1960:45 (routine assertSelectEquals)
\Framework\Assert.php:1961:22 (routine assertSelectEquals)
\Framework\Assert.php:1961:45 (routine assertSelectEquals)


CATEGORY: documentation
NOTE: assertSelectEquals uses the value as a parameter for PHPUnit_Util_XML::cssSelect that 
uses the value (without touching it at all) as a parameter for convertSelectToTag that 
has in its API documentation correctly stated that the parameter in question can be 'mixed', 
i.e. false is acceptable value.
\Framework\Assert.php:1896:21 (routine assertSelectCount)
The routine PHP.Core.AST.DirectStMtdCall expects type String|Null as its parameter number 1, but the expression is of type True.
        /**
         * Assert the presence, absence, or count of elements in a document matching
         * the CSS $selector, regardless of the contents of those elements.
         *
         * The first argument, $selector, is the CSS selector used to match
         * the elements in the $actual document.
         *
         * The second argument, $count, can be either boolean or numeric.
         * When boolean, it asserts for presence of elements matching the selector
         * (true) or absence of elements (false).
         * When numeric, it asserts the count of elements.
         *
         * assertSelectCount("#binder", true, $xml);  // any?
         * assertSelectCount(".binder", 3, $xml);     // exactly 3?
         *
         * @param array                 $selector
         * @param integer|boolean|array $count
         * @param mixed                 $actual
         * @param string                $message
         * @param boolean               $isHtml
         * @since  Method available since Release 3.3.0
         * @author Mike Naberezny <mike@maintainable.com>
         * @author Derek DeVries <derek@maintainable.com>
         */
        public static function assertSelectCount($selector, $count, $actual, $message = '', $isHtml = true)
        {
            self::assertSelectEquals(
>>>>          $selector, true, $count, $actual, $message, $isHtml
            );
        }
        

CATEGORY: documentation
CATEGORY: missing false        
\Util\Test.php:294:15 (routine getExpectedException)
The routine is expected to return type PhpArray|Null, the the expression false is of type False.
         * @param  string $className
         * @param  string $methodName
         * @return array
         * @since  Method available since Release 3.3.6
         */
        public static function getExpectedException($className, $methodName)
        {
            $reflector  = new ReflectionMethod($className, $methodName);
            $docComment = $reflector->getDocComment();
            $docComment = substr($docComment, 3, -2);
    
            if (preg_match(self::REGEX_EXPECTED_EXCEPTION, $docComment, $matches)) {
                $annotations = self::parseTestMethodAnnotations(
                  $className, $methodName
                );
    
                $class   = $matches[1];
                $code    = null;
                $message = '';
    
                if (isset($matches[2])) {
                    $message = trim($matches[2]);
                } elseif (isset($annotations['method']['expectedExceptionMessage'])) {
                    $message = self::parseAnnotationContent(
                        $annotations['method']['expectedExceptionMessage'][0]
                    );
                }
    
                if (isset($matches[3])) {
                    $code = $matches[3];
                } elseif (isset($annotations['method']['expectedExceptionCode'])) {
                    $code = self::parseAnnotationContent(
                        $annotations['method']['expectedExceptionCode'][0]
                    );
                }
    
                if (is_numeric($code)) {
                    $code = (int) $code;
                } elseif (is_string($code) && defined($code)) {
                    $code = (int) constant($code);
                }
    
                return array(
                  'class' => $class, 'code' => $code, 'message' => $message
                );
            }
    
>>>>        return false;
        }
        

CATEGORY: false positive
NOTE: support conversion from null to string when checking type mismatch
\Util\GlobalState.php:213:35 (routine getIniSettingsAsString)
The routine ini_get_all expects type String as its parameter number 0, but the expression is of type Null.
        public static function getIniSettingsAsString()
        {
            $result      = '';
>>>>        $iniSettings = ini_get_all(null, false);
    
            foreach ($iniSettings as $key => $value) {
                $result .= sprintf(
                  '@ini_set(%s, %s);' . "\n",
                  self::exportVariable($key),
                  self::exportVariable($value)
                );
            }
    
            return $result;
        }
        
        
CATEGORY: false positive
NOTE: assigning null to a field that has some class as its expected type. 
I.e. conversion null -> concrete class type should be OK>
\Framework\TestCase.php:761:15 (routine run)
Expression result is expected to be of type PHPUnit_Framework_TestResult, but it is of type Null.
         *
         * @param  PHPUnit_Framework_TestResult $result
         * @return PHPUnit_Framework_TestResult
         * @throws PHPUnit_Framework_Exception
         */
        public function run(PHPUnit_Framework_TestResult $result = null)
        {
            if ($result === null) {
                $result = $this->createResult();
            }
    
            if (!$this instanceof PHPUnit_Framework_Warning) {
                $this->setTestResultObject($result);
                $this->setUseErrorHandlerFromAnnotation();
            }
    
            if ($this->useErrorHandler !== null) {
                $oldErrorHandlerSetting = $result->getConvertErrorsToExceptions();
                $result->convertErrorsToExceptions($this->useErrorHandler);
            }
    
            if (!$this instanceof PHPUnit_Framework_Warning && !$this->handleDependencies()) {
                return;
            }
    
            if ($this->runTestInSeparateProcess === true &&
                $this->inIsolation !== true &&
                !$this instanceof PHPUnit_Extensions_SeleniumTestCase &&
                !$this instanceof PHPUnit_Extensions_PhptTestCase) {
                $class = new ReflectionClass($this);
    
                $template = new Text_Template(
                  __DIR__ . '/../Util/PHP/Template/TestCaseMethod.tpl'
                );
    
                if ($this->preserveGlobalState) {
                    $constants     = PHPUnit_Util_GlobalState::getConstantsAsString();
                    $globals       = PHPUnit_Util_GlobalState::getGlobalsAsString();
                    $includedFiles = PHPUnit_Util_GlobalState::getIncludedFilesAsString();
                    $iniSettings   = PHPUnit_Util_GlobalState::getIniSettingsAsString();
                } else {
                    $constants     = '';
                    $globals       = '';
                    $includedFiles = '';
                    $iniSettings   = '';
                }
    
                $coverage                                = $result->getCollectCodeCoverageInformation()       ? 'true' : 'false';
                $isStrictAboutTestsThatDoNotTestAnything = $result->isStrictAboutTestsThatDoNotTestAnything() ? 'true' : 'false';
                $isStrictAboutOutputDuringTests          = $result->isStrictAboutOutputDuringTests()          ? 'true' : 'false';
                $isStrictAboutTestSize                   = $result->isStrictAboutTestSize()                   ? 'true' : 'false';
                $isStrictAboutTodoAnnotatedTests         = $result->isStrictAboutTodoAnnotatedTests()         ? 'true' : 'false';
    
                if (defined('PHPUNIT_COMPOSER_INSTALL')) {
                    $composerAutoload = var_export(PHPUNIT_COMPOSER_INSTALL, true);
                } else {
                    $composerAutoload = '\'\'';
                }
    
                if (defined('__PHPUNIT_PHAR__')) {
                    $phar = var_export(__PHPUNIT_PHAR__, true);
                } else {
                    $phar = '\'\'';
                }
    
                $data            = var_export(serialize($this->data), true);
                $dependencyInput = var_export(serialize($this->dependencyInput), true);
                $includePath     = var_export(get_include_path(), true);
                // must do these fixes because TestCaseMethod.tpl has unserialize('{data}') in it, and we can't break BC
                // the lines above used to use addcslashes() rather than var_export(), which breaks null byte escape sequences
                $data            = "'." . $data . ".'";
                $dependencyInput = "'." . $dependencyInput . ".'";
                $includePath     = "'." . $includePath . ".'";
    
                $template->setVar(
                  array(
                    'composerAutoload'                        => $composerAutoload,
                    'phar'                                    => $phar,
                    'filename'                                => $class->getFileName(),
                    'className'                               => $class->getName(),
                    'methodName'                              => $this->name,
                    'collectCodeCoverageInformation'          => $coverage,
                    'data'                                    => $data,
                    'dataName'                                => $this->dataName,
                    'dependencyInput'                         => $dependencyInput,
                    'constants'                               => $constants,
                    'globals'                                 => $globals,
                    'include_path'                            => $includePath,
                    'included_files'                          => $includedFiles,
                    'iniSettings'                             => $iniSettings,
                    'isStrictAboutTestsThatDoNotTestAnything' => $isStrictAboutTestsThatDoNotTestAnything,
                    'isStrictAboutOutputDuringTests'          => $isStrictAboutOutputDuringTests,
                    'isStrictAboutTestSize'                   => $isStrictAboutTestSize,
                    'isStrictAboutTodoAnnotatedTests'         => $isStrictAboutTodoAnnotatedTests
                  )
                );
    
                $this->prepareTemplate($template);
    
                $php = PHPUnit_Util_PHP::factory();
                $php->runTestJob($template->render(), $this, $result);
            } else {
                $result->run($this);
            }
    
            if ($this->useErrorHandler !== null) {
                $result->convertErrorsToExceptions($oldErrorHandlerSetting);
            }
    
>>>>        $this->result = null;
    
            return $result;
        }
        
CATEGORY: false positive
NOTE: support for overloads of library methods, ReflectionProperty::setValue has two versions, 
one with 1 parameter and one with 2 parameters.
\Util\GlobalState.php:351:16 (routine restoreStaticAttributes)
The routine setValue is missing some of its mandatory parameters.
        public static function restoreStaticAttributes()
        {
            foreach (self::$staticAttributes as $className => $staticAttributes) {
                foreach ($staticAttributes as $name => $value) {
                    $reflector = new ReflectionProperty($className, $name);
                    $reflector->setAccessible(true);
>>>>                $reflector->setValue(unserialize($value));
                }
            }
    
            self::$staticAttributes = array();
        }
        
CATEGORY: false positive
NOTE: expected PhpArray, rejected null, why? PhpArray should be compatible with null be default.
\Framework\TestCase.php:1264:56 (routine setLocale)
The routine setlocale expects type PhpArray as its parameter number 1, but the expression is of type Null.
         * @param  integer                     $category
         * @param  string                      $locale
         * @throws PHPUnit_Framework_Exception
         * @since  Method available since Release 3.1.0
         */
        protected function setLocale()
        {
            $args = func_get_args();
    
            if (count($args) < 2) {
                throw new PHPUnit_Framework_Exception;
            }
    
            $category = $args[0];
            $locale   = $args[1];
    
            $categories = array(
              LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME
            );
    
            if (defined('LC_MESSAGES')) {
                $categories[] = LC_MESSAGES;
            }
    
            if (!in_array($category, $categories)) {
                throw new PHPUnit_Framework_Exception;
            }
    
            if (!is_array($locale) && !is_string($locale)) {
                throw new PHPUnit_Framework_Exception;
            }
    
>>>>        $this->locale[$category] = setlocale($category, null);
    
            $result = call_user_func_array( 'setlocale', $args );
    
            if ($result === false) {
                throw new PHPUnit_Framework_Exception(
                  'The locale functionality is not implemented on your platform, ' .
                  'the specified locale does not exist or the category name is ' .
                  'invalid.'
                );
            }
        }
        
CATEGORY: false positive
NOTE: expected PhpCallable, rejected string, but it should be compatible: 
add this conversion. Also array -> PhpCallable.
\Framework\TestCase.php:1266:40 (routine setLocale)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
         * @param  integer                     $category
         * @param  string                      $locale
         * @throws PHPUnit_Framework_Exception
         * @since  Method available since Release 3.1.0
         */
        protected function setLocale()
        {
            $args = func_get_args();
    
            if (count($args) < 2) {
                throw new PHPUnit_Framework_Exception;
            }
    
            $category = $args[0];
            $locale   = $args[1];
    
            $categories = array(
              LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME
            );
    
            if (defined('LC_MESSAGES')) {
                $categories[] = LC_MESSAGES;
            }
    
            if (!in_array($category, $categories)) {
                throw new PHPUnit_Framework_Exception;
            }
    
            if (!is_array($locale) && !is_string($locale)) {
                throw new PHPUnit_Framework_Exception;
            }
    
            $this->locale[$category] = setlocale($category, null);
    
>>>>        $result = call_user_func_array( 'setlocale', $args );
    
            if ($result === false) {
                throw new PHPUnit_Framework_Exception(
                  'The locale functionality is not implemented on your platform, ' .
                  'the specified locale does not exist or the category name is ' .
                  'invalid.'
                );
            }
        }
        

CATEGORY: documentation
NOTE: class field mockObjectGenerator is documented to be of type array, but 
instance of PHPUnit_Framework_MockObject_Generator is assigned to it. It is not 
used anywhere else, so the array doc should be changed to PHPUnit_Framework_MockObject_Generator
\Framework\TestCase.php:1941:19 (routine getMockObjectGenerator)
Expression mockObjectGenerator is expected to be of type PhpArray|Null, but it is of type PHPUnit_Framework_MockObject_Generator.
        /**
         * Get the mock object generator, creating it if it doesn't exist.
         *
         * @return   PHPUnit_Framework_MockObject_Generator
         */
        protected function getMockObjectGenerator()
        {
            if (null === $this->mockObjectGenerator) {
>>>>            $this->mockObjectGenerator = new PHPUnit_Framework_MockObject_Generator;
            }
    
            return $this->mockObjectGenerator;
        }
        
NOTE: The same as previous
\Framework\TestCase.php:1944:22 (routine getMockObjectGenerator)
The routine is expected to return type PHPUnit_Framework_MockObject_Generator, the the expression mockObjectGenerator is of type PhpArray|Null.
        /**
         * Get the mock object generator, creating it if it doesn't exist.
         *
         * @return   PHPUnit_Framework_MockObject_Generator
         */
        protected function getMockObjectGenerator()
        {
            if (null === $this->mockObjectGenerator) {
                $this->mockObjectGenerator = new PHPUnit_Framework_MockObject_Generator;
            }
    
>>>>        return $this->mockObjectGenerator;
        }

CATEGORY: style
CATEGORY: false positive
NOTE: may or may not be considered as false positive, the argument can be omitted, however, 
is used to preserve the same function signature.
\Util\Test.php:46:38 (routine trait_exists)
Variable $autoload is not used.
     * @link       http://www.phpunit.de/
     * @since      File available since Release 3.0.0
     */
    
    if (!function_exists('trait_exists')) {
>>>>    function trait_exists($traitname, $autoload = true)
        {
            return false;
        }
        


CATEGORY: false positive
NOTE: conversion from array to PhpCallable.
\Framework\TestResult.php:634:14 (routine run)
The routine set_error_handler expects type PhpCallable as its parameter number 0, but the expression is of type PhpArray.
        /**
         * Runs a TestCase.
         *
         * @param PHPUnit_Framework_Test $test
         */
        public function run(PHPUnit_Framework_Test $test)
        {
            PHPUnit_Framework_Assert::resetCount();
    
            $error      = false;
            $failure    = false;
            $incomplete = false;
            $risky      = false;
            $skipped    = false;
    
            $this->startTest($test);
    
            $errorHandlerSet = false;
    
            if ($this->convertErrorsToExceptions) {
                $oldErrorHandler = set_error_handler(
>>>>              array('PHPUnit_Util_ErrorHandler', 'handleError'),
                  E_ALL | E_STRICT
                );


CATEGORY: false positive
CATEGORY: inaccurate PHP manual
NOTE: ReflectionClass::newInstance expects variable number of arguments.
\Util\Test.php:360:26 (routine getProvidedData)
The routine newInstance is missing some of its mandatory parameters.
         *         false          when a data provider is specified but does not exist
         *         null           when no data provider is specified
         * @throws PHPUnit_Framework_Exception
         * @since  Method available since Release 3.2.0
         */
        public static function getProvidedData($className, $methodName)
        {
            $reflector  = new ReflectionMethod($className, $methodName);
            $docComment = $reflector->getDocComment();
            $data       = null;
    
            if (preg_match(self::REGEX_DATA_PROVIDER, $docComment, $matches)) {
                $dataProviderMethodNameNamespace = explode('\\', $matches[1]);
                $leaf                            = explode('::', array_pop($dataProviderMethodNameNamespace));
                $dataProviderMethodName          = array_pop($leaf);
    
                if (!empty($dataProviderMethodNameNamespace)) {
                    $dataProviderMethodNameNamespace = join('\\', $dataProviderMethodNameNamespace) . '\\';
                } else {
                    $dataProviderMethodNameNamespace = '';
                }
    
                if (!empty($leaf)) {
                    $dataProviderClassName = $dataProviderMethodNameNamespace . array_pop($leaf);
                } else {
                    $dataProviderClassName = $className;
                }
    
                $dataProviderClass  = new ReflectionClass($dataProviderClassName);
                $dataProviderMethod = $dataProviderClass->getMethod(
                  $dataProviderMethodName
                );
    
                if ($dataProviderMethod->isStatic()) {
                    $object = null;
                } else {
>>>>                $object = $dataProviderClass->newInstance();
                }
    
                if ($dataProviderMethod->getNumberOfParameters() == 0) {
                    $data = $dataProviderMethod->invoke($object);
                } else {
                    $data = $dataProviderMethod->invoke($object, $methodName);
                }
            }
    
            if ($data !== null) {
                if (is_object($data)) {
                    $data = iterator_to_array($data);
                }
    
                foreach ($data as $key => $value) {
                    if (!is_array($value)) {
                        throw new PHPUnit_Framework_Exception(
                          sprintf(
                            'Data set %s is invalid.',
                            is_int($key) ? '#' . $key : '"' . $key . '"'
                          )
                        );
                    }
                }
            }
    
            return $data;
        }
\Framework\TestSuite.php:382:55 (routine addTestFile)
The routine invoke expects type Object as its parameter number 0, but the expression is of type Null.
         *                                                  value the ini value.
         * @throws PHPUnit_Framework_Exception
         * @since  Method available since Release 2.3.0
         * @author Stefano F. Rausch <stefano@rausch-e.net>
         */
        public function addTestFile($filename, $phptOptions = array())
        {
            if (!is_string($filename)) {
                throw PHPUnit_Util_InvalidArgumentHelper::factory(1, 'string');
            }
    
            if (file_exists($filename) && substr($filename, -5) == '.phpt') {
                $this->addTest(
                  new PHPUnit_Extensions_PhptTestCase($filename, $phptOptions)
                );
    
                return;
            }
    
            $classes    = get_declared_classes();
            $filename   = PHPUnit_Util_Fileloader::checkAndLoad($filename);
            $newClasses = array_values(array_diff(get_declared_classes(), $classes));
            $baseName   = str_replace('.php', '', basename($filename));
    
            foreach ($newClasses as $className) {
                if (substr($className, 0 - strlen($baseName)) == $baseName) {
                    $class = new ReflectionClass($className);
    
                    if ($class->getFileName() == $filename) {
                        $newClasses = array($className);
                        break;
                    }
                }
            }
    
            foreach ($newClasses as $className) {
                $class = new ReflectionClass($className);
    
                if (!$class->isAbstract()) {
                    if ($class->hasMethod(PHPUnit_Runner_BaseTestRunner::SUITE_METHODNAME)) {
                        $method = $class->getMethod(
                          PHPUnit_Runner_BaseTestRunner::SUITE_METHODNAME
                        );
    
                        if ($method->isStatic()) {
>>>>                        $this->addTest($method->invoke(null, $className));
                        }
                    } elseif ($class->implementsInterface('PHPUnit_Framework_Test')) {
                        $this->addTestSuite($class);
                    }
                }
            }
    
            $this->numTests = -1;
        }
\Framework\TestSuite.php:737:19 (routine testAt)
The routine is expected to return type PHPUnit_Framework_Test, the the expression false is of type False.
         * Returns the test at the given index.
         *
         * @param  integer
         * @return PHPUnit_Framework_Test
         */
        public function testAt($index)
        {
            if (isset($this->tests[$index])) {
                return $this->tests[$index];
            } else {
>>>>            return false;
            }
        }
\Framework\Assert\Functions.php:55:6 (routine any)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * is executed zero or more times.
     *
     * @return PHPUnit_Framework_MockObject_Matcher_AnyInvokedCount
     * @since  Method available since Release 3.0.0
     */
    function any()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::any',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:69:6 (routine anything)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_IsAnything matcher object.
     *
     * @return PHPUnit_Framework_Constraint_IsAnything
     * @since  Method available since Release 3.0.0
     */
    function anything()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::anything',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:84:6 (routine arrayHasKey)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $key
     * @return PHPUnit_Framework_Constraint_ArrayHasKey
     * @since  Method available since Release 3.0.0
     */
    function arrayHasKey($key)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::arrayHasKey',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:100:6 (routine assertArrayHasKey)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed  $key
     * @param  array|ArrayAccess  $array
     * @param  string $message
     * @since  Method available since Release 3.0.0
     */
    function assertArrayHasKey($key, $array, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertArrayHasKey',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:116:6 (routine assertArrayNotHasKey)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed  $key
     * @param  array|ArrayAccess  $array
     * @param  string $message
     * @since  Method available since Release 3.0.0
     */
    function assertArrayNotHasKey($key, $array, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertArrayNotHasKey',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:137:6 (routine assertAttributeContains)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $ignoreCase
     * @param  boolean $checkForObjectIdentity
     * @param  boolean $checkForNonObjectIdentity
     * @since  Method available since Release 3.0.0
     */
    function assertAttributeContains($needle, $haystackAttributeName, $haystackClassOrObject, $message = '', $ignoreCase = false, $checkForObjectIdentity = true, $checkForNonObjectIdentity = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeContains',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:156:6 (routine assertAttributeContainsOnly)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $haystackClassOrObject
     * @param  boolean $isNativeType
     * @param  string  $message
     * @since  Method available since Release 3.1.4
     */
    function assertAttributeContainsOnly($type, $haystackAttributeName, $haystackClassOrObject, $isNativeType = null, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeContainsOnly',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:174:6 (routine assertAttributeCount)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string  $haystackAttributeName
     * @param mixed   $haystackClassOrObject
     * @param string  $message
     * @since Method available since Release 3.6.0
     */
    function assertAttributeCount($expectedCount, $haystackAttributeName, $haystackClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeCount',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:191:6 (routine assertAttributeEmpty)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $haystackAttributeName
     * @param mixed  $haystackClassOrObject
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertAttributeEmpty($haystackAttributeName, $haystackClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeEmpty',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:211:6 (routine assertAttributeEquals)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  float   $delta
     * @param  integer $maxDepth
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     */
    function assertAttributeEquals($expected, $actualAttributeName, $actualClassOrObject, $message = '', $delta = 0.0, $maxDepth = 10, $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeEquals',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:228:6 (routine assertAttributeGreaterThan)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $actualAttributeName
     * @param  string  $actualClassOrObject
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertAttributeGreaterThan($expected, $actualAttributeName, $actualClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeGreaterThan',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:245:6 (routine assertAttributeGreaterThanOrEqual)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $actualAttributeName
     * @param  string  $actualClassOrObject
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertAttributeGreaterThanOrEqual($expected, $actualAttributeName, $actualClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeGreaterThanOrEqual',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:262:6 (routine assertAttributeInstanceOf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $attributeName
     * @param mixed  $classOrObject
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertAttributeInstanceOf($expected, $attributeName, $classOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeInstanceOf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:279:6 (routine assertAttributeInternalType)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $attributeName
     * @param mixed  $classOrObject
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertAttributeInternalType($expected, $attributeName, $classOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeInternalType',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:296:6 (routine assertAttributeLessThan)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $actualAttributeName
     * @param  string  $actualClassOrObject
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertAttributeLessThan($expected, $actualAttributeName, $actualClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeLessThan',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:313:6 (routine assertAttributeLessThanOrEqual)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $actualAttributeName
     * @param  string  $actualClassOrObject
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertAttributeLessThanOrEqual($expected, $actualAttributeName, $actualClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeLessThanOrEqual',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:334:6 (routine assertAttributeNotContains)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $ignoreCase
     * @param  boolean $checkForObjectIdentity
     * @param  boolean $checkForNonObjectIdentity
     * @since  Method available since Release 3.0.0
     */
    function assertAttributeNotContains($needle, $haystackAttributeName, $haystackClassOrObject, $message = '', $ignoreCase = false, $checkForObjectIdentity = true, $checkForNonObjectIdentity = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotContains',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:354:6 (routine assertAttributeNotContainsOnly)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $haystackClassOrObject
     * @param  boolean $isNativeType
     * @param  string  $message
     * @since  Method available since Release 3.1.4
     */
    function assertAttributeNotContainsOnly($type, $haystackAttributeName, $haystackClassOrObject, $isNativeType = null, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotContainsOnly',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:372:6 (routine assertAttributeNotCount)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string  $haystackAttributeName
     * @param mixed   $haystackClassOrObject
     * @param string  $message
     * @since Method available since Release 3.6.0
     */
    function assertAttributeNotCount($expectedCount, $haystackAttributeName, $haystackClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotCount',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:389:6 (routine assertAttributeNotEmpty)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $haystackAttributeName
     * @param mixed  $haystackClassOrObject
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertAttributeNotEmpty($haystackAttributeName, $haystackClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotEmpty',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:409:6 (routine assertAttributeNotEquals)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  float   $delta
     * @param  integer $maxDepth
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     */
    function assertAttributeNotEquals($expected, $actualAttributeName, $actualClassOrObject, $message = '', $delta = 0.0, $maxDepth = 10, $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotEquals',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:426:6 (routine assertAttributeNotInstanceOf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $attributeName
     * @param mixed  $classOrObject
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertAttributeNotInstanceOf($expected, $attributeName, $classOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotInstanceOf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:443:6 (routine assertAttributeNotInternalType)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $attributeName
     * @param mixed  $classOrObject
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertAttributeNotInternalType($expected, $attributeName, $classOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotInternalType',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:460:6 (routine assertAttributeNotSame)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed  $expected
     * @param  string $actualAttributeName
     * @param  object $actualClassOrObject
     * @param  string $message
     */
    function assertAttributeNotSame($expected, $actualAttributeName, $actualClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeNotSame',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:477:6 (routine assertAttributeSame)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed  $expected
     * @param  string $actualAttributeName
     * @param  object $actualClassOrObject
     * @param  string $message
     */
    function assertAttributeSame($expected, $actualAttributeName, $actualClassOrObject, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertAttributeSame',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:493:6 (routine assertClassHasAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $attributeName
     * @param  string $className
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertClassHasAttribute($attributeName, $className, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertClassHasAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:509:6 (routine assertClassHasStaticAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $attributeName
     * @param  string $className
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertClassHasStaticAttribute($attributeName, $className, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertClassHasStaticAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:525:6 (routine assertClassNotHasAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $attributeName
     * @param  string $className
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertClassNotHasAttribute($attributeName, $className, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertClassNotHasAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:541:6 (routine assertClassNotHasStaticAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $attributeName
     * @param  string $className
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertClassNotHasStaticAttribute($attributeName, $className, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertClassNotHasStaticAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:560:6 (routine assertContains)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $ignoreCase
     * @param  boolean $checkForObjectIdentity
     * @param  boolean $checkForNonObjectIdentity
     * @since  Method available since Release 2.1.0
     */
    function assertContains($needle, $haystack, $message = '', $ignoreCase = false, $checkForObjectIdentity = true, $checkForNonObjectIdentity = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertContains',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:577:6 (routine assertContainsOnly)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $haystack
     * @param  boolean $isNativeType
     * @param  string  $message
     * @since  Method available since Release 3.1.4
     */
    function assertContainsOnly($type, $haystack, $isNativeType = null, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertContainsOnly',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:592:6 (routine assertContainsOnlyInstancesOf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param string $classname
     * @param array|Traversable $haystack
     * @param string $message
     */
    function assertContainsOnlyInstancesOf($classname, $haystack, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertContainsOnlyInstancesOf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:607:6 (routine assertCount)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param integer $expectedCount
     * @param mixed   $haystack
     * @param string  $message
     */
    function assertCount($expectedCount, $haystack, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertCount',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:622:6 (routine assertEmpty)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed   $actual
     * @param  string  $message
     * @throws PHPUnit_Framework_AssertionFailedError
     */
    function assertEmpty($actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertEmpty',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:640:6 (routine assertEqualXMLStructure)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param boolean $checkAttributes
     * @param string  $message
     * @author Mattis Stordalen Flister <mattis@xait.no>
     * @since  Method available since Release 3.3.0
     */
    function assertEqualXMLStructure(DOMElement $expectedElement, DOMElement $actualElement, $checkAttributes = false, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertEqualXMLStructure',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:659:6 (routine assertEquals)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  float   $delta
     * @param  integer $maxDepth
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     */
    function assertEquals($expected, $actual, $message = '', $delta = 0.0, $maxDepth = 10, $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertEquals',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:674:6 (routine assertNotTrue)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  boolean  $condition
     * @param  string   $message
     * @throws PHPUnit_Framework_AssertionFailedError
     */
    function assertNotTrue($condition, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotTrue',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:689:6 (routine assertFalse)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  boolean  $condition
     * @param  string   $message
     * @throws PHPUnit_Framework_AssertionFailedError
     */
    function assertFalse($condition, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertFalse',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:708:6 (routine assertFileEquals)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $message
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     * @since  Method available since Release 3.2.14
     */
    function assertFileEquals($expected, $actual, $message = '', $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertFileEquals',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:723:6 (routine assertFileExists)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $filename
     * @param  string $message
     * @since  Method available since Release 3.0.0
     */
    function assertFileExists($filename, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertFileExists',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:742:6 (routine assertFileNotEquals)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $message
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     * @since  Method available since Release 3.2.14
     */
    function assertFileNotEquals($expected, $actual, $message = '', $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertFileNotEquals',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:757:6 (routine assertFileNotExists)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $filename
     * @param  string $message
     * @since  Method available since Release 3.0.0
     */
    function assertFileNotExists($filename, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertFileNotExists',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:773:6 (routine assertGreaterThan)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $expected
     * @param  mixed   $actual
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertGreaterThan($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertGreaterThan',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:789:6 (routine assertGreaterThanOrEqual)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $expected
     * @param  mixed   $actual
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertGreaterThanOrEqual($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertGreaterThanOrEqual',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:805:6 (routine assertInstanceOf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $expected
     * @param mixed  $actual
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertInstanceOf($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertInstanceOf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:821:6 (routine assertInternalType)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $expected
     * @param mixed  $actual
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertInternalType($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertInternalType',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:836:6 (routine assertJson)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $filename
     * @param  string $message
     * @since  Method available since Release 3.7.20
     */
    function assertJson($expectedJson, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertJson',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:851:6 (routine assertJsonFileEqualsJsonFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $expectedFile
     * @param  string $actualFile
     * @param  string $message
     */
    function assertJsonFileEqualsJsonFile($expectedFile, $actualFile, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertJsonFileEqualsJsonFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:866:6 (routine assertJsonFileNotEqualsJsonFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $expectedFile
     * @param  string $actualFile
     * @param  string $message
     */
    function assertJsonFileNotEqualsJsonFile($expectedFile, $actualFile, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertJsonFileNotEqualsJsonFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:881:6 (routine assertJsonStringEqualsJsonFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param string $expectedFile
     * @param string $actualJson
     * @param string $message
     */
    function assertJsonStringEqualsJsonFile($expectedFile, $actualJson, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertJsonStringEqualsJsonFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:896:6 (routine assertJsonStringEqualsJsonString)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param string $expectedJson
     * @param string $actualJson
     * @param string $message
     */
    function assertJsonStringEqualsJsonString($expectedJson, $actualJson, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertJsonStringEqualsJsonString',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:911:6 (routine assertJsonStringNotEqualsJsonFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param string $expectedFile
     * @param string $actualJson
     * @param string $message
     */
    function assertJsonStringNotEqualsJsonFile($expectedFile, $actualJson, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertJsonStringNotEqualsJsonFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:926:6 (routine assertJsonStringNotEqualsJsonString)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param string $expectedJson
     * @param string $actualJson
     * @param string $message
     */
    function assertJsonStringNotEqualsJsonString($expectedJson, $actualJson, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertJsonStringNotEqualsJsonString',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:942:6 (routine assertLessThan)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $expected
     * @param  mixed   $actual
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertLessThan($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertLessThan',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:958:6 (routine assertLessThanOrEqual)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $expected
     * @param  mixed   $actual
     * @param  string  $message
     * @since  Method available since Release 3.1.0
     */
    function assertLessThanOrEqual($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertLessThanOrEqual',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:977:6 (routine assertNotContains)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $ignoreCase
     * @param  boolean $checkForObjectIdentity
     * @param  boolean $checkForNonObjectIdentity
     * @since  Method available since Release 2.1.0
     */
    function assertNotContains($needle, $haystack, $message = '', $ignoreCase = false, $checkForObjectIdentity = true, $checkForNonObjectIdentity = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotContains',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:994:6 (routine assertNotContainsOnly)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed   $haystack
     * @param  boolean $isNativeType
     * @param  string  $message
     * @since  Method available since Release 3.1.4
     */
    function assertNotContainsOnly($type, $haystack, $isNativeType = null, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotContainsOnly',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1009:6 (routine assertNotCount)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param integer $expectedCount
     * @param mixed   $haystack
     * @param string  $message
     */
    function assertNotCount($expectedCount, $haystack, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotCount',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1024:6 (routine assertNotEmpty)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed   $actual
     * @param  string  $message
     * @throws PHPUnit_Framework_AssertionFailedError
     */
    function assertNotEmpty($actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotEmpty',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1044:6 (routine assertNotEquals)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  integer $maxDepth
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     * @since  Method available since Release 2.3.0
     */
    function assertNotEquals($expected, $actual, $message = '', $delta = 0.0, $maxDepth = 10, $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotEquals',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1060:6 (routine assertNotInstanceOf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $expected
     * @param mixed  $actual
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertNotInstanceOf($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotInstanceOf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1076:6 (routine assertNotInternalType)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param string $expected
     * @param mixed  $actual
     * @param string $message
     * @since Method available since Release 3.5.0
     */
    function assertNotInternalType($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotInternalType',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1091:6 (routine assertNotFalse)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  boolean  $condition
     * @param  string   $message
     * @throws PHPUnit_Framework_AssertionFailedError
     */
    function assertNotFalse($condition, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotFalse',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1105:6 (routine assertNotNull)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Asserts that a variable is not null.
     *
     * @param  mixed  $actual
     * @param  string $message
     */
    function assertNotNull($actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotNull',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1121:6 (routine assertNotRegExp)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $pattern
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 2.1.0
     */
    function assertNotRegExp($pattern, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotRegExp',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1138:6 (routine assertNotSame)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed  $expected
     * @param  mixed  $actual
     * @param  string $message
     */
    function assertNotSame($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotSame',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1154:6 (routine assertNotSameSize)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param array|Countable|Traversable $expected
     * @param array|Countable|Traversable $actual
     * @param string $message
     */
    function assertNotSameSize($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotSameSize',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1176:6 (routine assertNotTag)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $isHtml
     * @since  Method available since Release 3.3.0
     * @author Mike Naberezny <mike@maintainable.com>
     * @author Derek DeVries <derek@maintainable.com>
     */
    function assertNotTag($matcher, $actual, $message = '', $isHtml = true)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNotTag',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1190:6 (routine assertNull)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Asserts that a variable is null.
     *
     * @param  mixed  $actual
     * @param  string $message
     */
    function assertNull($actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertNull',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1206:6 (routine assertObjectHasAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $attributeName
     * @param  object $object
     * @param  string $message
     * @since  Method available since Release 3.0.0
     */
    function assertObjectHasAttribute($attributeName, $object, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertObjectHasAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1222:6 (routine assertObjectNotHasAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $attributeName
     * @param  object $object
     * @param  string $message
     * @since  Method available since Release 3.0.0
     */
    function assertObjectNotHasAttribute($attributeName, $object, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertObjectNotHasAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1237:6 (routine assertRegExp)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $pattern
     * @param  string $string
     * @param  string $message
     */
    function assertRegExp($pattern, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertRegExp',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1254:6 (routine assertSame)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed  $expected
     * @param  mixed  $actual
     * @param  string $message
     */
    function assertSame($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertSame',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1270:6 (routine assertSameSize)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param array|Countable|Traversable $expected
     * @param array|Countable|Traversable $actual
     * @param string $message
     */
    function assertSameSize($expected, $actual, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertSameSize',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1302:6 (routine assertSelectCount)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $isHtml
     * @since  Method available since Release 3.3.0
     * @author Mike Naberezny <mike@maintainable.com>
     * @author Derek DeVries <derek@maintainable.com>
     */
    function assertSelectCount($selector, $count, $actual, $message = '', $isHtml = true)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertSelectCount',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1324:6 (routine assertSelectEquals)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $isHtml
     * @since  Method available since Release 3.3.0
     * @author Mike Naberezny <mike@maintainable.com>
     * @author Derek DeVries <derek@maintainable.com>
     */
    function assertSelectEquals($selector, $content, $count, $actual, $message = '', $isHtml = true)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertSelectEquals',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1346:6 (routine assertSelectRegExp)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $isHtml
     * @since  Method available since Release 3.3.0
     * @author Mike Naberezny <mike@maintainable.com>
     * @author Derek DeVries <derek@maintainable.com>
     */
    function assertSelectRegExp($selector, $pattern, $count, $actual, $message = '', $isHtml = true)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertSelectRegExp',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1362:6 (routine assertStringEndsNotWith)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $suffix
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.4.0
     */
    function assertStringEndsNotWith($suffix, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringEndsNotWith',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1378:6 (routine assertStringEndsWith)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $suffix
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.4.0
     */
    function assertStringEndsWith($suffix, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringEndsWith',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1397:6 (routine assertStringEqualsFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $message
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     * @since  Method available since Release 3.3.0
     */
    function assertStringEqualsFile($expectedFile, $actualString, $message = '', $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringEqualsFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1413:6 (routine assertStringMatchesFormat)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $format
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.5.0
     */
    function assertStringMatchesFormat($format, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringMatchesFormat',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1429:6 (routine assertStringMatchesFormatFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $formatFile
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.5.0
     */
    function assertStringMatchesFormatFile($formatFile, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringMatchesFormatFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1448:6 (routine assertStringNotEqualsFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $message
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     * @since  Method available since Release 3.3.0
     */
    function assertStringNotEqualsFile($expectedFile, $actualString, $message = '', $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringNotEqualsFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1464:6 (routine assertStringNotMatchesFormat)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $format
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.5.0
     */
    function assertStringNotMatchesFormat($format, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringNotMatchesFormat',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1480:6 (routine assertStringNotMatchesFormatFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $formatFile
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.5.0
     */
    function assertStringNotMatchesFormatFile($formatFile, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringNotMatchesFormatFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1496:6 (routine assertStringStartsNotWith)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $prefix
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.4.0
     */
    function assertStringStartsNotWith($prefix, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringStartsNotWith',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1512:6 (routine assertStringStartsWith)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $prefix
     * @param  string $string
     * @param  string $message
     * @since  Method available since Release 3.4.0
     */
    function assertStringStartsWith($prefix, $string, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertStringStartsWith',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1657:6 (routine assertTag)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $isHtml
     * @since  Method available since Release 3.3.0
     * @author Mike Naberezny <mike@maintainable.com>
     * @author Derek DeVries <derek@maintainable.com>
     */
    function assertTag($matcher, $actual, $message = '', $isHtml = true)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertTag',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1673:6 (routine assertThat)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  mixed$value
     * @param  PHPUnit_Framework_Constraint $constraint
     * @param  string   $message
     * @since  Method available since Release 3.0.0
     */
    function assertThat($value, PHPUnit_Framework_Constraint $constraint, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertThat',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1688:6 (routine assertTrue)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  boolean $condition
     * @param  string  $message
     * @throws PHPUnit_Framework_AssertionFailedError
     */
    function assertTrue($condition, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertTrue',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1704:6 (routine assertXmlFileEqualsXmlFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $expectedFile
     * @param  string $actualFile
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertXmlFileEqualsXmlFile($expectedFile, $actualFile, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertXmlFileEqualsXmlFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1720:6 (routine assertXmlFileNotEqualsXmlFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $expectedFile
     * @param  string $actualFile
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertXmlFileNotEqualsXmlFile($expectedFile, $actualFile, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertXmlFileNotEqualsXmlFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1736:6 (routine assertXmlStringEqualsXmlFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $expectedFile
     * @param  string $actualXml
     * @param  string $message
     * @since  Method available since Release 3.3.0
     */
    function assertXmlStringEqualsXmlFile($expectedFile, $actualXml, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertXmlStringEqualsXmlFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1752:6 (routine assertXmlStringEqualsXmlString)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $expectedXml
     * @param  string $actualXml
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertXmlStringEqualsXmlString($expectedXml, $actualXml, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertXmlStringEqualsXmlString',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1768:6 (routine assertXmlStringNotEqualsXmlFile)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $expectedFile
     * @param  string $actualXml
     * @param  string $message
     * @since  Method available since Release 3.3.0
     */
    function assertXmlStringNotEqualsXmlFile($expectedFile, $actualXml, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertXmlStringNotEqualsXmlFile',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1784:6 (routine assertXmlStringNotEqualsXmlString)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string $expectedXml
     * @param  string $actualXml
     * @param  string $message
     * @since  Method available since Release 3.1.0
     */
    function assertXmlStringNotEqualsXmlString($expectedXml, $actualXml, $message = '')
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::assertXmlStringNotEqualsXmlString',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1800:6 (routine at)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  integer $index
     * @return PHPUnit_Framework_MockObject_Matcher_InvokedAtIndex
     * @since  Method available since Release 3.0.0
     */
    function at($index)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::at',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1815:6 (routine atLeastOnce)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * is executed at least once.
     *
     * @return PHPUnit_Framework_MockObject_Matcher_InvokedAtLeastOnce
     * @since  Method available since Release 3.0.0
     */
    function atLeastOnce()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::atLeastOnce',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1831:6 (routine attribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  PHPUnit_Framework_Constraint $constraint
     * @param  string   $attributeName
     * @return PHPUnit_Framework_Constraint_Attribute
     * @since  Method available since Release 3.1.0
     */
    function attribute(PHPUnit_Framework_Constraint $constraint, $attributeName)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::attribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1853:6 (routine attributeEqualTo)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     * @return PHPUnit_Framework_Constraint_Attribute
     * @since  Method available since Release 3.1.0
     */
    function attributeEqualTo($attributeName, $value, $delta = 0.0, $maxDepth = 10, $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::attributeEqualTo',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1867:6 (routine callback)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_Callback matcher object.
     *
     * @param callable $callback
     * @return PHPUnit_Framework_Constraint_Callback
     */
    function callback($callback)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::callback',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1882:6 (routine classHasAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $attributeName
     * @return PHPUnit_Framework_Constraint_ClassHasAttribute
     * @since  Method available since Release 3.1.0
     */
    function classHasAttribute($attributeName)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::classHasAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1898:6 (routine classHasStaticAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $attributeName
     * @return PHPUnit_Framework_Constraint_ClassHasStaticAttribute
     * @since  Method available since Release 3.1.0
     */
    function classHasStaticAttribute($attributeName)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::classHasStaticAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1916:6 (routine contains)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $checkForObjectIdentity
     * @param  boolean $checkForNonObjectIdentity
     * @return PHPUnit_Framework_Constraint_TraversableContains
     * @since  Method available since Release 3.0.0
     */
    function contains($value, $checkForObjectIdentity = true, $checkForNonObjectIdentity = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::contains',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1932:6 (routine containsOnly)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $type
     * @return PHPUnit_Framework_Constraint_TraversableContainsOnly
     * @since  Method available since Release 3.1.4
     */
    function containsOnly($type)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::containsOnly',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1947:6 (routine containsOnlyInstancesOf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * object.
     *
     * @param string $classname
     * @return PHPUnit_Framework_Constraint_TraversableContainsOnly
     */
    function containsOnlyInstancesOf($classname)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::containsOnlyInstancesOf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1966:6 (routine equalTo)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  boolean $canonicalize
     * @param  boolean $ignoreCase
     * @return PHPUnit_Framework_Constraint_IsEqual
     * @since  Method available since Release 3.0.0
     */
    function equalTo($value, $delta = 0.0, $maxDepth = 10, $canonicalize = false, $ignoreCase = false)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::equalTo',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1982:6 (routine exactly)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  integer $count
     * @return PHPUnit_Framework_MockObject_Matcher_InvokedCount
     * @since  Method available since Release 3.0.0
     */
    function exactly($count)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::exactly',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:1996:6 (routine fileExists)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_FileExists matcher object.
     *
     * @return PHPUnit_Framework_Constraint_FileExists
     * @since  Method available since Release 3.0.0
     */
    function fileExists()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::fileExists',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2011:6 (routine greaterThan)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $value
     * @return PHPUnit_Framework_Constraint_GreaterThan
     * @since  Method available since Release 3.0.0
     */
    function greaterThan($value)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::greaterThan',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2028:6 (routine greaterThanOrEqual)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $value
     * @return PHPUnit_Framework_Constraint_Or
     * @since  Method available since Release 3.1.0
     */
    function greaterThanOrEqual($value)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::greaterThanOrEqual',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2043:6 (routine identicalTo)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $value
     * @return PHPUnit_Framework_Constraint_IsIdentical
     * @since  Method available since Release 3.0.0
     */
    function identicalTo($value)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::identicalTo',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2057:6 (routine isEmpty)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_IsEmpty matcher object.
     *
     * @return PHPUnit_Framework_Constraint_IsEmpty
     * @since  Method available since Release 3.5.0
     */
    function isEmpty()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::isEmpty',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2071:6 (routine isFalse)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_IsFalse matcher object.
     *
     * @return PHPUnit_Framework_Constraint_IsFalse
     * @since  Method available since Release 3.3.0
     */
    function isFalse()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::isFalse',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2086:6 (routine isInstanceOf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $className
     * @return PHPUnit_Framework_Constraint_IsInstanceOf
     * @since  Method available since Release 3.0.0
     */
    function isInstanceOf($className)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::isInstanceOf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2100:6 (routine isJson)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_IsJson matcher object.
     *
     * @return PHPUnit_Framework_Constraint_IsJson
     * @since  Method available since Release 3.7.20
     */
    function isJson()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::isJson',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2114:6 (routine isNull)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_IsNull matcher object.
     *
     * @return PHPUnit_Framework_Constraint_IsNull
     * @since  Method available since Release 3.3.0
     */
    function isNull()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::isNull',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2128:6 (routine isTrue)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_IsTrue matcher object.
     *
     * @return PHPUnit_Framework_Constraint_IsTrue
     * @since  Method available since Release 3.3.0
     */
    function isTrue()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::isTrue',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2143:6 (routine isType)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $type
     * @return PHPUnit_Framework_Constraint_IsType
     * @since  Method available since Release 3.0.0
     */
    function isType($type)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::isType',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2158:6 (routine lessThan)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $value
     * @return PHPUnit_Framework_Constraint_LessThan
     * @since  Method available since Release 3.0.0
     */
    function lessThan($value)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::lessThan',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2175:6 (routine lessThanOrEqual)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $value
     * @return PHPUnit_Framework_Constraint_Or
     * @since  Method available since Release 3.1.0
     */
    function lessThanOrEqual($value)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::lessThanOrEqual',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2189:6 (routine logicalAnd)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_And matcher object.
     *
     * @return PHPUnit_Framework_Constraint_And
     * @since  Method available since Release 3.0.0
     */
    function logicalAnd()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::logicalAnd',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2204:6 (routine logicalNot)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  PHPUnit_Framework_Constraint $constraint
     * @return PHPUnit_Framework_Constraint_Not
     * @since  Method available since Release 3.0.0
     */
    function logicalNot(PHPUnit_Framework_Constraint $constraint)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::logicalNot',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2218:6 (routine logicalOr)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_Or matcher object.
     *
     * @return PHPUnit_Framework_Constraint_Or
     * @since  Method available since Release 3.0.0
     */
    function logicalOr()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::logicalOr',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2232:6 (routine logicalXor)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * Returns a PHPUnit_Framework_Constraint_Xor matcher object.
     *
     * @return PHPUnit_Framework_Constraint_Xor
     * @since  Method available since Release 3.0.0
     */
    function logicalXor()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::logicalXor',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2247:6 (routine matches)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $string
     * @return PHPUnit_Framework_Constraint_StringMatches
     * @since  Method available since Release 3.5.0
     */
    function matches($string)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::matches',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2262:6 (routine matchesRegularExpression)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $pattern
     * @return PHPUnit_Framework_Constraint_PCREMatch
     * @since  Method available since Release 3.0.0
     */
    function matchesRegularExpression($pattern)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::matchesRegularExpression',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2277:6 (routine never)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * is never executed.
     *
     * @return PHPUnit_Framework_MockObject_Matcher_InvokedCount
     * @since  Method available since Release 3.0.0
     */
    function never()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::never',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2292:6 (routine objectHasAttribute)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  string $attributeName
     * @return PHPUnit_Framework_Constraint_ObjectHasAttribute
     * @since  Method available since Release 3.0.0
     */
    function objectHasAttribute($attributeName)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::objectHasAttribute',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2305:6 (routine onConsecutiveCalls)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
    /**
     * @param  mixed $value, ...
     * @return PHPUnit_Framework_MockObject_Stub_ConsecutiveCalls
     * @since  Method available since Release 3.0.0
     */
    function onConsecutiveCalls()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::onConsecutiveCalls',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2320:6 (routine once)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * is executed exactly once.
     *
     * @return PHPUnit_Framework_MockObject_Matcher_InvokedCount
     * @since  Method available since Release 3.0.0
     */
    function once()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::once',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2335:6 (routine returnArgument)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  integer $argumentIndex
     * @return PHPUnit_Framework_MockObject_Stub_ReturnArgument
     * @since  Method available since Release 3.3.0
     */
    function returnArgument($argumentIndex)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::returnArgument',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2350:6 (routine returnCallback)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $callback
     * @return PHPUnit_Framework_MockObject_Stub_ReturnCallback
     * @since  Method available since Release 3.3.0
     */
    function returnCallback($callback)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::returnCallback',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2366:6 (routine returnSelf)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * This method is useful when mocking a fluent interface.
     *
     * @return PHPUnit_Framework_MockObject_Stub_ReturnSelf
     * @since  Method available since Release 3.6.0
     */
    function returnSelf()
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::returnSelf',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2381:6 (routine returnValue)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $value
     * @return PHPUnit_Framework_MockObject_Stub_Return
     * @since  Method available since Release 3.0.0
     */
    function returnValue($value)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::returnValue',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2396:6 (routine returnValueMap)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  array $valueMap
     * @return PHPUnit_Framework_MockObject_Stub_ReturnValueMap
     * @since  Method available since Release 3.6.0
     */
    function returnValueMap(array $valueMap)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::returnValueMap',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2412:6 (routine stringContains)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     * @param  string  $string
     * @param  boolean $case
     * @return PHPUnit_Framework_Constraint_StringContains
     * @since  Method available since Release 3.0.0
     */
    function stringContains($string, $case = true)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::stringContains',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2427:6 (routine stringEndsWith)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $suffix
     * @return PHPUnit_Framework_Constraint_StringEndsWith
     * @since  Method available since Release 3.4.0
     */
    function stringEndsWith($suffix)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::stringEndsWith',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2442:6 (routine stringStartsWith)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  mixed $prefix
     * @return PHPUnit_Framework_Constraint_StringStartsWith
     * @since  Method available since Release 3.4.0
     */
    function stringStartsWith($prefix)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_Assert::stringStartsWith',
          func_get_args()
        );
    }
\Framework\Assert\Functions.php:2457:6 (routine throwException)
The routine call_user_func_array expects type PhpCallable as its parameter number 0, but the expression is of type String.
     *
     * @param  Exception $exception
     * @return PHPUnit_Framework_MockObject_Stub_Exception
     * @since  Method available since Release 3.1.0
     */
    function throwException(Exception $exception)
    {
        return call_user_func_array(
>>>>      'PHPUnit_Framework_TestCase::throwException',
          func_get_args()
        );
    }
\Framework\Constraint\Count.php:90:23 (routine getCountOf)
The routine getCountOf is supposed to return a value of type 1000000000110000, but some of the possible execution paths do not return.
    
        /**
         * @param  mixed   $other
         * @return boolean
         */
>>>>    protected function getCountOf($other)
        {
            if ($other instanceof Countable || is_array($other)) {
                return count($other);
            }
    
            else if ($other instanceof Traversable) {
                if ($other instanceof IteratorAggregate) {
                    $iterator = $other->getIterator();
                } else {
                    $iterator = $other;
                }
    
                $key = $iterator->key();
                $count = iterator_count($iterator);
    
                // manually rewind $iterator to previous key, since iterator_count
                // moves pointer
                if ($key !== null) {
                    $iterator->rewind();
                    while ($key !== $iterator->key()) {
                        $iterator->next();
                    }
                }
    
                return $count;
            }
        }
\Framework\Constraint\Count.php:100:28 (routine getCountOf)
Variable $other is used before it got assigned any value. This can generate a notice at runtime.
    
        /**
         * @param  mixed   $other
         * @return boolean
         */
        protected function getCountOf($other)
        {
            if ($other instanceof Countable || is_array($other)) {
                return count($other);
            }
    
            else if ($other instanceof Traversable) {
                if ($other instanceof IteratorAggregate) {
                    $iterator = $other->getIterator();
                } else {
>>>>                $iterator = $other;
                }
    
                $key = $iterator->key();
                $count = iterator_count($iterator);
    
                // manually rewind $iterator to previous key, since iterator_count
                // moves pointer
                if ($key !== null) {
                    $iterator->rewind();
                    while ($key !== $iterator->key()) {
                        $iterator->next();
                    }
                }
    
                return $count;
            }
        }
\Framework\Constraint\Count.php:115:19 (routine getCountOf)
The routine is expected to return type , the the expression $count is of type Integer.
    
        /**
         * @param  mixed   $other
         * @return boolean
         */
        protected function getCountOf($other)
        {
            if ($other instanceof Countable || is_array($other)) {
                return count($other);
            }
    
            else if ($other instanceof Traversable) {
                if ($other instanceof IteratorAggregate) {
                    $iterator = $other->getIterator();
                } else {
                    $iterator = $other;
                }
    
                $key = $iterator->key();
                $count = iterator_count($iterator);
    
                // manually rewind $iterator to previous key, since iterator_count
                // moves pointer
                if ($key !== null) {
                    $iterator->rewind();
                    while ($key !== $iterator->key()) {
                        $iterator->next();
                    }
                }
    
>>>>            return $count;
            }
        }
\Framework\Constraint\ExceptionMessage.php:69:15 (routine __construct)
Expression expectedMessage is expected to be of type Integer, but it is of type String|Null.
        protected $expectedMessage;
    
        /**
         * @param string $expected
         */
        public function __construct($expected)
        {
            parent::__construct();
>>>>        $this->expectedMessage = $expected;
        }
\Framework\Constraint\IsAnything.php:76:37 (routine evaluate)
Variable $description is not used.
         * @param  string                                       $description  Additional information about the test
         * @param  bool                                         $returnResult Whether to return a result or throw an exception
         * @return mixed
         * @throws PHPUnit_Framework_ExpectationFailedException
         */
>>>>    public function evaluate($other, $description = '', $returnResult = false)
        {
            return $returnResult ? true : null;
        }
\Framework\Constraint\IsJson.php:88:10 (routine failureDescription)
The routine PHP.Core.AST.DirectStMtdCall expects type String|Null as its parameter number 0, but the expression is of type Integer.
         * cases. This method should return the second part of that sentence.
         *
         * @param  mixed  $other Evaluated value or object.
         * @return string
         */
        protected function failureDescription($other)
        {
            json_decode($other);
            $error = PHPUnit_Framework_Constraint_JsonMatches_ErrorMessageProvider::determineJsonError(
>>>>          json_last_error()
            );
    
            return sprintf(
              '%s is valid JSON (%s)',
    
              $this->exporter->shortenedExport($other),
              $error
            );
        }
\Framework\Constraint\IsType.php:127:23 (routine matches)
The routine matches is supposed to return a value of type 1000000000110000, but some of the possible execution paths do not return.
         * constraint is met, false otherwise.
         *
         * @param  mixed $other Value or object to evaluate.
         * @return bool
         */
>>>>    protected function matches($other)
        {
            switch ($this->type) {
                case 'numeric': {
                    return is_numeric($other);
                }
    
                case 'integer':
                case 'int': {
                    return is_integer($other);
                }
    
                case 'float': {
                    return is_float($other);
                }
    
                case 'string': {
                    return is_string($other);
                }
    
                case 'boolean':
                case 'bool': {
                    return is_bool($other);
                }
    
                case 'null': {
                    return is_null($other);
                }
    
                case 'array': {
                    return is_array($other);
                }
    
                case 'object': {
                    return is_object($other);
                }
    
                case 'resource': {
                    return is_resource($other);
                }
    
                case 'scalar': {
                    return is_scalar($other);
                }
    
                case 'callable': {
                    return is_callable($other);
                }
            }
        }
\Runner\BaseTestRunner.php:108:19 (routine getTest)
The routine is expected to return type PHPUnit_Framework_Test, the the expression null is of type Null.
         * @param  string                 $suiteClassName
         * @param  string                 $suiteClassFile
         * @param  mixed                  $suffixes
         * @return PHPUnit_Framework_Test
         */
        public function getTest($suiteClassName, $suiteClassFile = '', $suffixes = '')
        {
            if (is_dir($suiteClassName) &&
                !is_file($suiteClassName . '.php') && empty($suiteClassFile)) {
                $facade = new File_Iterator_Facade;
                $files  = $facade->getFilesAsArray(
                  $suiteClassName, $suffixes
                );
    
                $suite = new PHPUnit_Framework_TestSuite($suiteClassName);
                $suite->addTestFiles($files);
    
                return $suite;
            }
    
            try {
                $testClass = $this->loadSuiteClass(
                  $suiteClassName, $suiteClassFile
                );
            } catch (PHPUnit_Framework_Exception $e) {
                $this->runFailed($e->getMessage());
    
>>>>            return null;
            }
    
            try {
                $suiteMethod = $testClass->getMethod(self::SUITE_METHODNAME);
    
                if (!$suiteMethod->isStatic()) {
                    $this->runFailed(
                      'suite() method must be static.'
                    );
    
                    return null;
                }
    
                try {
                    $test = $suiteMethod->invoke(null, $testClass->getName());
                } catch (ReflectionException $e) {
                    $this->runFailed(
                      sprintf(
                        "Failed to invoke suite() method.\n%s",
    
                        $e->getMessage()
                      )
                    );
    
                    return null;
                }
            } catch (ReflectionException $e) {
                try {
                    $test = new PHPUnit_Framework_TestSuite($testClass);
                } catch (PHPUnit_Framework_Exception $e) {
                    $test = new PHPUnit_Framework_TestSuite;
                    $test->setName($suiteClassName);
                }
            }
    
            $this->clearStatus();
    
            return $test;
        }
\Runner\BaseTestRunner.php:119:23 (routine getTest)
The routine is expected to return type PHPUnit_Framework_Test, the the expression null is of type Null.
         * @param  string                 $suiteClassName
         * @param  string                 $suiteClassFile
         * @param  mixed                  $suffixes
         * @return PHPUnit_Framework_Test
         */
        public function getTest($suiteClassName, $suiteClassFile = '', $suffixes = '')
        {
            if (is_dir($suiteClassName) &&
                !is_file($suiteClassName . '.php') && empty($suiteClassFile)) {
                $facade = new File_Iterator_Facade;
                $files  = $facade->getFilesAsArray(
                  $suiteClassName, $suffixes
                );
    
                $suite = new PHPUnit_Framework_TestSuite($suiteClassName);
                $suite->addTestFiles($files);
    
                return $suite;
            }
    
            try {
                $testClass = $this->loadSuiteClass(
                  $suiteClassName, $suiteClassFile
                );
            } catch (PHPUnit_Framework_Exception $e) {
                $this->runFailed($e->getMessage());
    
                return null;
            }
    
            try {
                $suiteMethod = $testClass->getMethod(self::SUITE_METHODNAME);
    
                if (!$suiteMethod->isStatic()) {
                    $this->runFailed(
                      'suite() method must be static.'
                    );
    
>>>>                return null;
                }
    
                try {
                    $test = $suiteMethod->invoke(null, $testClass->getName());
                } catch (ReflectionException $e) {
                    $this->runFailed(
                      sprintf(
                        "Failed to invoke suite() method.\n%s",
    
                        $e->getMessage()
                      )
                    );
    
                    return null;
                }
            } catch (ReflectionException $e) {
                try {
                    $test = new PHPUnit_Framework_TestSuite($testClass);
                } catch (PHPUnit_Framework_Exception $e) {
                    $test = new PHPUnit_Framework_TestSuite;
                    $test->setName($suiteClassName);
                }
            }
    
            $this->clearStatus();
    
            return $test;
        }
\Runner\BaseTestRunner.php:133:23 (routine getTest)
The routine is expected to return type PHPUnit_Framework_Test, the the expression null is of type Null.
         * @param  string                 $suiteClassName
         * @param  string                 $suiteClassFile
         * @param  mixed                  $suffixes
         * @return PHPUnit_Framework_Test
         */
        public function getTest($suiteClassName, $suiteClassFile = '', $suffixes = '')
        {
            if (is_dir($suiteClassName) &&
                !is_file($suiteClassName . '.php') && empty($suiteClassFile)) {
                $facade = new File_Iterator_Facade;
                $files  = $facade->getFilesAsArray(
                  $suiteClassName, $suffixes
                );
    
                $suite = new PHPUnit_Framework_TestSuite($suiteClassName);
                $suite->addTestFiles($files);
    
                return $suite;
            }
    
            try {
                $testClass = $this->loadSuiteClass(
                  $suiteClassName, $suiteClassFile
                );
            } catch (PHPUnit_Framework_Exception $e) {
                $this->runFailed($e->getMessage());
    
                return null;
            }
    
            try {
                $suiteMethod = $testClass->getMethod(self::SUITE_METHODNAME);
    
                if (!$suiteMethod->isStatic()) {
                    $this->runFailed(
                      'suite() method must be static.'
                    );
    
                    return null;
                }
    
                try {
                    $test = $suiteMethod->invoke(null, $testClass->getName());
                } catch (ReflectionException $e) {
                    $this->runFailed(
                      sprintf(
                        "Failed to invoke suite() method.\n%s",
    
                        $e->getMessage()
                      )
                    );
    
>>>>                return null;
                }
            } catch (ReflectionException $e) {
                try {
                    $test = new PHPUnit_Framework_TestSuite($testClass);
                } catch (PHPUnit_Framework_Exception $e) {
                    $test = new PHPUnit_Framework_TestSuite;
                    $test->setName($suiteClassName);
                }
            }
    
            $this->clearStatus();
    
            return $test;
        }
\Util\Getopt.php:177:25 (routine parseLongOption)
Expression strlen($opt_arg) is expected to be of type String|PhpArray|Object, but it is of type Integer.
    
                $opts[] = array($opt, $opt_arg);
            }
        }
    
        protected static function parseLongOption($arg, $long_options, &$opts, &$args)
        {
            $count   = count($long_options);
            $list    = explode('=', $arg);
            $opt     = $list[0];
            $opt_arg = null;
    
            if (count($list) > 1) {
                $opt_arg = $list[1];
            }
    
            $opt_len = strlen($opt);
    
            for ($i = 0; $i < $count; $i++) {
                $long_opt  = $long_options[$i];
                $opt_start = substr($long_opt, 0, $opt_len);
    
                if ($opt_start != $opt) {
                    continue;
                }
    
                $opt_rest = substr($long_opt, $opt_len);
    
                if ($opt_rest != '' && $opt[0] != '=' && $i + 1 < $count &&
                    $opt == substr($long_options[$i+1], 0, $opt_len)) {
                    throw new PHPUnit_Framework_Exception(
                      "option --$opt is ambiguous"
                    );
                }
    
                if (substr($long_opt, -1) == '=') {
                    if (substr($long_opt, -2) != '==') {
>>>>                    if (!strlen($opt_arg) &&
                            !(list(, $opt_arg) = each($args))) {
                            throw new PHPUnit_Framework_Exception(
                              "option --$opt requires an argument"
                            );
                        }
                    }
                } elseif ($opt_arg) {
                    throw new PHPUnit_Framework_Exception(
                      "option --$opt doesn't allow an argument"
                    );
                }
    
                $opts[] = array('--' . $opt, $opt_arg);
    
                return;
            }
    
            throw new PHPUnit_Framework_Exception("unrecognized option --$opt");
        }
\TextUI\Command.php:765:23 (routine handlePrinter)
The routine handlePrinter is supposed to return a value of type type codes: Object, classes: PHPUnit_Util_Printer, subclasses: True, typehint: True, but some of the possible execution paths do not return.
         *
         * @param  string               $printerClass
         * @param  string               $printerFile
         * @return PHPUnit_Util_Printer
         */
>>>>    protected function handlePrinter($printerClass, $printerFile = '')
        {
            if (!class_exists($printerClass, false)) {
                if ($printerFile == '') {
                    $printerFile = PHPUnit_Util_Filesystem::classNameToFilename(
                      $printerClass
                    );
                }
    
                $printerFile = stream_resolve_include_path($printerFile);
    
                if ($printerFile) {
                    require $printerFile;
                }
            }
    
            if (class_exists($printerClass)) {
                $class = new ReflectionClass($printerClass);
    
                if ($class->implementsInterface('PHPUnit_Framework_TestListener') &&
                    $class->isSubclassOf('PHPUnit_Util_Printer') &&
                    $class->isInstantiable()) {
                    if ($class->isSubclassOf('PHPUnit_TextUI_ResultPrinter')) {
                        return $printerClass;
                    }
    
                    return $class->newInstance();
                }
            }
    
            $this->showError(
              sprintf(
                'Could not use "%s" as printer.',
    
                $printerClass
              )
            );
        }
\TextUI\Command.php:791:23 (routine handlePrinter)
The routine newInstance is missing some of its mandatory parameters.
         *
         * @param  string               $printerClass
         * @param  string               $printerFile
         * @return PHPUnit_Util_Printer
         */
        protected function handlePrinter($printerClass, $printerFile = '')
        {
            if (!class_exists($printerClass, false)) {
                if ($printerFile == '') {
                    $printerFile = PHPUnit_Util_Filesystem::classNameToFilename(
                      $printerClass
                    );
                }
    
                $printerFile = stream_resolve_include_path($printerFile);
    
                if ($printerFile) {
                    require $printerFile;
                }
            }
    
            if (class_exists($printerClass)) {
                $class = new ReflectionClass($printerClass);
    
                if ($class->implementsInterface('PHPUnit_Framework_TestListener') &&
                    $class->isSubclassOf('PHPUnit_Util_Printer') &&
                    $class->isInstantiable()) {
                    if ($class->isSubclassOf('PHPUnit_TextUI_ResultPrinter')) {
                        return $printerClass;
                    }
    
>>>>                return $class->newInstance();
                }
            }
    
            $this->showError(
              sprintf(
                'Could not use "%s" as printer.',
    
                $printerClass
              )
            );
        }
\TextUI\Command.php:724:23 (routine handleLoader)
The routine handleLoader is supposed to return a value of type type codes: Object, classes: PHPUnit_Runner_TestSuiteLoader, subclasses: True, typehint: True, but some of the possible execution paths do not return.
         *
         * @param  string                         $loaderClass
         * @param  string                         $loaderFile
         * @return PHPUnit_Runner_TestSuiteLoader
         */
>>>>    protected function handleLoader($loaderClass, $loaderFile = '')
        {
            if (!class_exists($loaderClass, false)) {
                if ($loaderFile == '') {
                    $loaderFile = PHPUnit_Util_Filesystem::classNameToFilename(
                      $loaderClass
                    );
                }
    
                $loaderFile = stream_resolve_include_path($loaderFile);
    
                if ($loaderFile) {
                    require $loaderFile;
                }
            }
    
            if (class_exists($loaderClass, false)) {
                $class = new ReflectionClass($loaderClass);
    
                if ($class->implementsInterface('PHPUnit_Runner_TestSuiteLoader') &&
                    $class->isInstantiable()) {
                    return $class->newInstance();
                }
            }
    
            $this->showError(
              sprintf(
                'Could not use "%s" as loader.',
    
                $loaderClass
              )
            );
        }
\TextUI\Command.php:745:23 (routine handleLoader)
The routine newInstance is missing some of its mandatory parameters.
         *
         * @param  string                         $loaderClass
         * @param  string                         $loaderFile
         * @return PHPUnit_Runner_TestSuiteLoader
         */
        protected function handleLoader($loaderClass, $loaderFile = '')
        {
            if (!class_exists($loaderClass, false)) {
                if ($loaderFile == '') {
                    $loaderFile = PHPUnit_Util_Filesystem::classNameToFilename(
                      $loaderClass
                    );
                }
    
                $loaderFile = stream_resolve_include_path($loaderFile);
    
                if ($loaderFile) {
                    require $loaderFile;
                }
            }
    
            if (class_exists($loaderClass, false)) {
                $class = new ReflectionClass($loaderClass);
    
                if ($class->implementsInterface('PHPUnit_Runner_TestSuiteLoader') &&
                    $class->isInstantiable()) {
>>>>                return $class->newInstance();
                }
            }
    
            $this->showError(
              sprintf(
                'Could not use "%s" as loader.',
    
                $loaderClass
              )
            );
        }
\TextUI\Command.php:339:45 (routine handleArguments)
The routine ini_set expects type String as its parameter number 1, but the expression is of type True.
         * }
         * </code>
         *
         * @param array $argv
         */
        protected function handleArguments(array $argv)
        {
            if (defined('__PHPUNIT_PHAR__')) {
                $this->longOptions['selfupdate']  = null;
                $this->longOptions['self-update'] = null;
            }
    
            try {
                $this->options = PHPUnit_Util_Getopt::getopt(
                  $argv,
                  'd:c:hv',
                  array_keys($this->longOptions)
                );
            } catch (PHPUnit_Framework_Exception $e) {
                $this->showError($e->getMessage());
            }
    
            foreach ($this->options[0] as $option) {
                switch ($option[0]) {
                    case '--colors': {
                        $this->arguments['colors'] = true;
                    }
                    break;
    
                    case '--bootstrap': {
                        $this->arguments['bootstrap'] = $option[1];
                    }
                    break;
    
                    case 'c':
                    case '--configuration': {
                        $this->arguments['configuration'] = $option[1];
                    }
                    break;
    
                    case '--coverage-clover': {
                        $this->arguments['coverageClover'] = $option[1];
                    }
                    break;
    
                    case '--coverage-crap4j': {
                        $this->arguments['coverageCrap4J'] = $option[1];
                    }
                    break;
    
                    case '--coverage-html': {
                        $this->arguments['coverageHtml'] = $option[1];
                    }
                    break;
    
                    case '--coverage-php': {
                        $this->arguments['coveragePHP'] = $option[1];
                    }
                    break;
    
                    case '--coverage-text': {
                        if ($option[1] === null) {
                            $option[1] = 'php://stdout';
                        }
    
                        $this->arguments['coverageText'] = $option[1];
                        $this->arguments['coverageTextShowUncoveredFiles'] = false;
                        $this->arguments['coverageTextShowOnlySummary'] = false;
                    }
                    break;
    
                    case '--coverage-xml': {
                        $this->arguments['coverageXml'] = $option[1];
                    }
                    break;
    
                    case 'd': {
                        $ini = explode('=', $option[1]);
    
                        if (isset($ini[0])) {
                            if (isset($ini[1])) {
                                ini_set($ini[0], $ini[1]);
                            } else {
>>>>                            ini_set($ini[0], true);
                            }
                        }
                    }
                    break;
    
                    case '--debug': {
                        $this->arguments['debug'] = true;
                    }
                    break;
    
                    case 'h':
                    case '--help': {
                        $this->showHelp();
                        exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
                    }
                    break;
    
                    case '--filter': {
                        $this->arguments['filter'] = $option[1];
                    }
                    break;
    
                    case '--testsuite': {
                        $this->arguments['testsuite'] = $option[1];
                    }
                    break;
    
                    case '--group': {
                        $this->arguments['groups'] = explode(',', $option[1]);
                    }
                    break;
    
                    case '--exclude-group': {
                        $this->arguments['excludeGroups'] = explode(
                          ',', $option[1]
                        );
                    }
                    break;
    
                    case '--test-suffix': {
                        $this->arguments['testSuffixes'] = explode(
                          ',', $option[1]
                        );
                    }
                    break;
    
                    case '--include-path': {
                        $includePath = $option[1];
                    }
                    break;
    
                    case '--list-groups': {
                        $this->arguments['listGroups'] = true;
                    }
                    break;
    
                    case '--printer': {
                        $this->arguments['printer'] = $option[1];
                    }
                    break;
    
                    case '--loader': {
                        $this->arguments['loader'] = $option[1];
                    }
                    break;
    
                    case '--log-json': {
                        $this->arguments['jsonLogfile'] = $option[1];
                    }
                    break;
    
                    case '--log-junit': {
                        $this->arguments['junitLogfile'] = $option[1];
                    }
                    break;
    
                    case '--log-tap': {
                        $this->arguments['tapLogfile'] = $option[1];
                    }
                    break;
    
                    case '--process-isolation': {
                        $this->arguments['processIsolation'] = true;
                    }
                    break;
    
                    case '--repeat': {
                        $this->arguments['repeat'] = (int) $option[1];
                    }
                    break;
    
                    case '--stderr': {
                        $this->arguments['stderr'] = true;
                    }
                    break;
    
                    case '--stop-on-error': {
                        $this->arguments['stopOnError'] = true;
                    }
                    break;
    
                    case '--stop-on-failure': {
                        $this->arguments['stopOnFailure'] = true;
                    }
                    break;
    
                    case '--stop-on-incomplete': {
                        $this->arguments['stopOnIncomplete'] = true;
                    }
                    break;
    
                    case '--stop-on-risky': {
                        $this->arguments['stopOnRisky'] = true;
                    }
                    break;
    
                    case '--stop-on-skipped': {
                        $this->arguments['stopOnSkipped'] = true;
                    }
                    break;
    
                    case '--tap': {
                        $this->arguments['printer'] = new PHPUnit_Util_Log_TAP;
                    }
                    break;
    
                    case '--testdox': {
                        $this->arguments['printer'] = new PHPUnit_Util_TestDox_ResultPrinter_Text;
                    }
                    break;
    
                    case '--testdox-html': {
                        $this->arguments['testdoxHTMLFile'] = $option[1];
                    }
                    break;
    
                    case '--testdox-text': {
                        $this->arguments['testdoxTextFile'] = $option[1];
                    }
                    break;
    
                    case '--no-configuration': {
                        $this->arguments['useDefaultConfiguration'] = false;
                    }
                    break;
    
                    case '--no-globals-backup': {
                        $this->arguments['backupGlobals'] = false;
                    }
                    break;
    
                    case '--static-backup': {
                        $this->arguments['backupStaticAttributes'] = true;
                    }
                    break;
    
                    case 'v':
                    case '--verbose': {
                        $this->arguments['verbose'] = true;
                    }
                    break;
    
                    case '--version': {
                        $this->printVersionString();
                        exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT);
                    }
                    break;
    
                    case '--report-useless-tests': {
                        $this->arguments['reportUselessTests'] = true;
                    }
                    break;
    
                    case '--strict-coverage': {
                        $this->arguments['strictCoverage'] = true;
                    }
                    break;
    
                    case '--disallow-test-output': {
                        $this->arguments['disallowTestOutput'] = true;
                    }
                    break;
    
                    case '--enforce-time-limit': {
                        $this->arguments['enforceTimeLimit'] = true;
                    }
                    break;
    
                    case '--disallow-todo-tests': {
                        $this->arguments['disallowTodoAnnotatedTests'] = true;
                    }
                    break;
    
                    case '--strict': {
                        $this->arguments['reportUselessTests']         = true;
                        $this->arguments['strictCoverage']             = true;
                        $this->arguments['disallowTestOutput']         = true;
                        $this->arguments['enforceTimeLimit']           = true;
                        $this->arguments['disallowTodoAnnotatedTests'] = true;
                    }
                    break;
    
                    case '--selfupdate':
                    case '--self-update': {
                        $this->handleSelfUpdate();
                    }
                    break;
    
                    default: {
                        $optionName = str_replace('--', '', $option[0]);
    
                        if (isset($this->longOptions[$optionName])) {
                            $handler = $this->longOptions[$optionName];
                        } elseif (isset($this->longOptions[$optionName . '='])) {
                            $handler = $this->longOptions[$optionName . '='];
                        }
    
                        if (isset($handler) && is_callable(array($this, $handler))) {
                            $this->$handler($option[1]);
                        }
                    }
                }
            }
    
            $this->handleCustomTestSuite();
    
            if (!isset($this->arguments['test'])) {
    
                if (isset($this->options[1][0])) {
                    $this->arguments['test'] = $this->options[1][0];
                }
    
                if (isset($this->options[1][1])) {
                    $this->arguments['testFile'] = realpath($this->options[1][1]);
                } else {
                    $this->arguments['testFile'] = '';
                }
    
                if (isset($this->arguments['test']) &&
                    is_file($this->arguments['test']) &&
                    substr($this->arguments['test'], -5, 5) != '.phpt') {
                    $this->arguments['testFile'] = realpath($this->arguments['test']);
                    $this->arguments['test']     = substr($this->arguments['test'], 0, strrpos($this->arguments['test'], '.'));
                }
            }
    
            if (!isset($this->arguments['testSuffixes'])) {
                $this->arguments['testSuffixes'] = array('Test.php', '.phpt');
            }
    
            if (isset($includePath)) {
                ini_set(
                  'include_path',
                  $includePath . PATH_SEPARATOR . ini_get('include_path')
                );
            }
    
            if (isset($this->arguments['bootstrap'])) {
                $this->handleBootstrap($this->arguments['bootstrap']);
            }
    
            if (isset($this->arguments['printer']) &&
                is_string($this->arguments['printer'])) {
                $this->arguments['printer'] = $this->handlePrinter($this->arguments['printer']);
            }
    
            if ($this->arguments['loader'] !== null) {
                $this->arguments['loader'] = $this->handleLoader($this->arguments['loader']);
            }
    
            if (isset($this->arguments['configuration']) &&
                is_dir($this->arguments['configuration'])) {
                $configurationFile = $this->arguments['configuration'] .
                                     '/phpunit.xml';
    
                if (file_exists($configurationFile)) {
                    $this->arguments['configuration'] = realpath(
                      $configurationFile
                    );
                } elseif (file_exists($configurationFile . '.dist')) {
                    $this->arguments['configuration'] = realpath(
                      $configurationFile . '.dist'
                    );
                }
            } elseif (!isset($this->arguments['configuration']) &&
                     $this->arguments['useDefaultConfiguration']) {
                if (file_exists('phpunit.xml')) {
                    $this->arguments['configuration'] = realpath('phpunit.xml');
                } elseif (file_exists('phpunit.xml.dist')) {
                    $this->arguments['configuration'] = realpath(
                      'phpunit.xml.dist'
                    );
                }
            }
    
            if (isset($this->arguments['configuration'])) {
                try {
                    $configuration = PHPUnit_Util_Configuration::getInstance(
                      $this->arguments['configuration']
                    );
                } catch (Exception $e) {
                    print $e->getMessage() . "\n";
                    exit(PHPUnit_TextUI_TestRunner::FAILURE_EXIT);
                }
    
                $phpunit = $configuration->getPHPUnitConfiguration();
    
                $configuration->handlePHPConfiguration();
    
                if (!isset($this->arguments['bootstrap']) && isset($phpunit['bootstrap'])) {
                    $this->handleBootstrap($phpunit['bootstrap']);
                }
    
                /**
                 * Issue #657
                 */
                if (isset($phpunit['stderr']) && $phpunit['stderr'] == true) {
                    $this->arguments['printer'] = new PHPUnit_TextUI_ResultPrinter(
                      'php://stderr',
                      isset($this->arguments['verbose']) ? $this->arguments['verbose'] : FALSE
                    );
                }
    
                if (isset($phpunit['printerClass'])) {
                    if (isset($phpunit['printerFile'])) {
                        $file = $phpunit['printerFile'];
                    } else {
                        $file = '';
                    }
    
                    $this->arguments['printer'] = $this->handlePrinter(
                      $phpunit['printerClass'], $file
                    );
                }
    
                if (isset($phpunit['testSuiteLoaderClass'])) {
                    if (isset($phpunit['testSuiteLoaderFile'])) {
                        $file = $phpunit['testSuiteLoaderFile'];
                    } else {
                        $file = '';
                    }
    
                    $this->arguments['loader'] = $this->handleLoader(
                      $phpunit['testSuiteLoaderClass'], $file
                    );
                }
    
                $browsers = $configuration->getSeleniumBrowserConfiguration();
    
                if (!empty($browsers) &&
                    class_exists('PHPUnit_Extensions_SeleniumTestCase')) {
                    PHPUnit_Extensions_SeleniumTestCase::$browsers = $browsers;
                }
    
                if (!isset($this->arguments['test'])) {
                    $testSuite = $configuration->getTestSuiteConfiguration(isset($this->arguments['testsuite']) ? $this->arguments['testsuite'] : null);
    
                    if ($testSuite !== null) {
                        $this->arguments['test'] = $testSuite;
                    }
                }
            }
    
            if (isset($this->arguments['test']) && is_string($this->arguments['test']) && substr($this->arguments['test'], -5, 5) == '.phpt') {
                $test = new PHPUnit_Extensions_PhptTestCase($this->arguments['test']);
    
                $this->arguments['test'] = new PHPUnit_Framework_TestSuite;
                $this->arguments['test']->addTest($test);
            }
    
            if (!isset($this->arguments['test']) ||
                (isset($this->arguments['testDatabaseLogRevision']) && !isset($this->arguments['testDatabaseDSN']))) {
                $this->showHelp();
                exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT);
            }
        }
\Util\Configuration.php:991:19 (routine getInteger)
The routine is expected to return type , the the expression (int) $value is of type Integer.
         * @param  string  $value
         * @param  boolean $default
         * @return boolean
         * @since  Method available since Release 3.6.0
         */
        protected function getInteger($value, $default)
        {
            if (is_numeric($value)) {
>>>>            return (int) $value;
            }
    
            return $default;
        }
\Util\Configuration.php:823:20 (routine getTestSuiteConfiguration)
The routine getTestSuiteConfiguration is supposed to return a value of type type codes: Object, classes: PHPUnit_Framework_TestSuite, subclasses: True, typehint: True, but some of the possible execution paths do not return.
         * Returns the test suite configuration.
         *
         * @return PHPUnit_Framework_TestSuite
         * @since  Method available since Release 3.2.1
         */
>>>>    public function getTestSuiteConfiguration($testSuiteFilter=null)
        {
            $testSuiteNodes = $this->xpath->query('testsuites/testsuite');
    
            if ($testSuiteNodes->length == 0) {
                $testSuiteNodes = $this->xpath->query('testsuite');
            }
    
            if ($testSuiteNodes->length == 1) {
                return $this->getTestSuite($testSuiteNodes->item(0), $testSuiteFilter);
            }
    
            if ($testSuiteNodes->length > 1) {
                $suite = new PHPUnit_Framework_TestSuite;
    
                foreach ($testSuiteNodes as $testSuiteNode) {
                    $suite->addTestSuite(
                      $this->getTestSuite($testSuiteNode, $testSuiteFilter)
                    );
                }
    
                return $suite;
            }
        }
\Util\DeprecatedFeature\Logger.php:198:8 (routine startTest)
Expression self::$currentTest is expected to be of type PHPUnit_Framework_TestCase, but it is of type PHPUnit_Framework_Test.
        /**
         * A test started.
         *
         * @param PHPUnit_Framework_Test $test
         */
        public function startTest(PHPUnit_Framework_Test $test)
        {
>>>>        self::$currentTest = $test;
        }
\Util\DeprecatedFeature\Logger.php:209:8 (routine endTest)
Expression self::$currentTest is expected to be of type PHPUnit_Framework_TestCase, but it is of type Null.
         * A test ended.
         *
         * @param PHPUnit_Framework_Test $test
         * @param float                  $time
         */
        public function endTest(PHPUnit_Framework_Test $test, $time)
        {
>>>>        self::$currentTest = null;
        }
\Util\Log\JUnit.php:452:15 (routine endTest)
Expression currentTestCase is expected to be of type DOMElement, but it is of type Null.
         * A test ended.
         *
         * @param PHPUnit_Framework_Test $test
         * @param float                  $time
         */
        public function endTest(PHPUnit_Framework_Test $test, $time)
        {
            if (!$test instanceof PHPUnit_Framework_Warning) {
                if ($this->attachCurrentTestCase) {
                    if ($test instanceof PHPUnit_Framework_TestCase) {
                        $numAssertions = $test->getNumAssertions();
                        $this->testSuiteAssertions[$this->testSuiteLevel] += $numAssertions;
    
                        $this->currentTestCase->setAttribute(
                          'assertions', $numAssertions
                        );
                    }
    
                    $this->currentTestCase->setAttribute(
                      'time', sprintf('%F', $time)
                    );
    
                    $this->testSuites[$this->testSuiteLevel]->appendChild(
                      $this->currentTestCase
                    );
    
                    $this->testSuiteTests[$this->testSuiteLevel]++;
                    $this->testSuiteTimes[$this->testSuiteLevel] += $time;
    
                    if (method_exists($test, 'hasOutput') && $test->hasOutput()) {
                        $systemOut = $this->document->createElement('system-out');
                        $systemOut->appendChild(
                          $this->document->createTextNode($test->getActualOutput())
                        );
                        $this->currentTestCase->appendChild($systemOut);
                    }
                }
            }
    
            $this->attachCurrentTestCase = true;
>>>>        $this->currentTestCase       = null;
        }
\Util\TestDox\ResultPrinter.php:266:31 (routine startTest)
Variable $test is used before it got assigned any value. This can generate a notice at runtime.
        /**
         * A test started.
         *
         * @param PHPUnit_Framework_Test $test
         */
        public function startTest(PHPUnit_Framework_Test $test)
        {
            if ($test instanceof $this->testTypeOfInterest) {
                $class = get_class($test);
    
                if ($this->testClass != $class) {
                    if ($this->testClass != '') {
                        $this->doEndClass();
                    }
    
                    $this->currentTestClassPrettified = $this->prettifier->prettifyTestClass($class);
                    $this->startClass($class);
    
                    $this->testClass = $class;
                    $this->tests     = array();
                }
    
                $prettified = false;
    
                if ($test instanceof PHPUnit_Framework_TestCase &&
                   !$test instanceof PHPUnit_Framework_Warning) {
>>>>                $annotations = $test->getAnnotations();
    
                    if (isset($annotations['method']['testdox'][0])) {
                        $this->currentTestMethodPrettified = $annotations['method']['testdox'][0];
                        $prettified                        = true;
                    }
                }
    
                if (!$prettified) {
                    $this->currentTestMethodPrettified = $this->prettifier->prettifyTestMethod($test->getName(false));
                }
    
                $this->testStatus = PHPUnit_Runner_BaseTestRunner::STATUS_PASSED;
            }
        }
