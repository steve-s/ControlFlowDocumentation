%pygmentize_options: -O startinline=True
\chapter{Results}


\section{Comparison to Phantm\label{phantmresults}}



\section{Evaluation on open source PHP code}

The project has been evaluated on the following open source PHP frameworks and 
websites.

\begin{description}
    \item[PHPUnit:] a port of JUnit unit testing framework for PHP; it is a mature 
    and well established project that has been developed for more than 6 years 
    by 156 contributors. Being a unit testing framework, PHPUnit itself has extensive 
    unit test suite. For the experiment the master branch of the clone of the 
    repository retrieved on 18.5.2014 has been used. 
    
    \item[Zend Framework:] popular general purpose PHP framework. Lorem ipsum...
        \note{over 3000 problems reported. Quite a big bite to chew with analysing and categorizing all of them.}
        
    \item[Nette:] another popular PHP framework for building websites.
        \note{Findings not so impressive: 1 (probably only) documentation error :(}
        
    \item[Piwik:] open source version of Google Analytics. \note{few hundred problems found, not categorized yet}
    
    \item[PrestaShop:] open source e-commerce solution. \note{few hundred problems found, not categorized yet}
    
    \item[Composer:] popular dependency management system for PHP libraries. \note{few hundred problems found, not categorized yet}
\end{description}

An evaluation always started with downloading a git repository with the 
latest source code of given PHP project. Then the analysis was run and 
all the discovered problems were collected and categorized.
Actual errors were rectified and recorded as commits in the 
git repository. 

Often one real issue in the source code caused several 
warnings to be reported by the tool. For instance, if a documentation 
of a type of a field was not correct, most the lines where 
a value was assigned to that field were reported, however, the 
root of the cause was actually the only one line with the 
wrong type documentation. Such cases were counted as a 
single problem.

\subsection{Problems Taxonomy}

The problems were divided into few main categories 
described below. Some of the problems recurring 
across all the projects are discussed in this section, 
while the more project specific problems are 
investigated later each project's section.

\paragraph*{Style:} a category of problems that 
are not directly affecting the functionality of the 
application, but they can be considered as a bad 
coding style. 

\begin{itemize}
    \item[] \textit{Relaying on default return value} -- when an execution of a 
        routine does not end with a return statement, its 
        return value is \code{NULL} by default, which can then 
        be cast to values of other types, like \code{false} 
        for example. Developers rely on this feature and omit 
        the return statement if they want to return \code{NULL} or 
        something that \code{NULL} can be cast to.
\end{itemize}

\paragraph*{Documentation:} inconsistency of the PHPDoc type 
documentation and what the the code does. This category includes 
only cases where it is clear that the documentation is wrong, not the code, 
for example, due to updates in the code that were not reflected 
in the documentation. The inconsistency may also indicate 
another problem, in which case it does not belong to this category. 

Interestingly, most of the inconsistencies of type of a parameter 
of a function call typically lead through several routines that 
only forward the parameter to the next routine until 
eventually the routine that has a wrong documentation is reached.

\begin{itemize}
    \item[] \textit{Missing} \code{false} \textit{in return value type documentation} -- 
        this is common pattern in PHP where a routine returns \code{false} 
        when it fails to do what it was supposed to do. For example, 
        function \code{fopen} returns \code{resource} of \code{false} 
        if the resource could not be opened. It is so common that 
        developers tend to forget to put \code{false} into the documentation.
\end{itemize}

\paragraph*{Actual Error:} includes all problems that can cause 
an unexpected exception or unexpected runtime error or notice.


\paragraph*{False Positive:} problems reported by the tool that 
are not in fact real problems. Includes only false positives 
that cannot be eliminated because of fundamental design reasons 
or are not intended to be eliminated, because it would 
cause some actual positives to be missed.


\begin{itemize}
    \item[] \textit{Unused routine arguments} -- when a method is an override of 
        some base method, it can have the same signature and if some of the 
        parameters are not used, they are not reported. There are however 
        some cases where the routine is implementing some interface by convention 
        that is not explicitly expressed in the syntax of PHP.
        For example, the pre-object-oriented pattern for global functions 
        overriding. In such case the analyzer cannot determine that the unused 
        parameter is in fact a part of an interface. Note that such function 
        could omit the unused parameter and everything would work the same, 
        therefore this may or may not be considered a false positive.
    \item[] \textit{Amendable false positive} -- false positives 
        that are reported, although the algorithm the analyzer 
        is using should not report them. Those indicate errors 
        in the implementation.
    \item[] \textit{Built-in documentation errors} -- false positives 
        due to the inaccuracy of the documentation of built-in 
        functions and classes that was used in the experiment.
\end{itemize}

\subsection{Summary}

The following table provides a summary of the problems found. 
There is a table that lists concrete problems found PHPUnit 
available in appendix.

\newcommand{\subcat}[1]{\hspace{0.5cm}\small{\textit{#1}}} 
\newcommand{\reldefret}{\subcat{default return value}}

\newcommand{\sumh}[1]{\textbf{#1}}
%\newcommand{\sumh}[1]{\begin{turn}{60}#1\end{turn}}

\begin{center}
    \begin{tabular}{| p{5cm} | r | r | r | r | r |}
    \hline
    \sumh{Category}         &   \sumh{PHPUnit}      &   \sumh{Zend}       &   \sumh{Nette}    &   \sumh{WP}    &   \sumh{total}   \\ \hline
    Style                   &   6                   &       NA                      &   NA              &   NA                  &   6       \\ \hline
    \reldefret              &   2                   &       NA                      &   NA              &   NA                  &   2       \\ \hline        
    Documentation           &   10                  &       NA                      &   NA              &   NA                  &   10      \\ \hline    
    \subcat{missing false}  &   3                   &       NA                      &   NA              &   NA                  &   3       \\ \hline
    Actual Error            &   1                   &       NA                      &   NA              &   NA                  &   1      \\ \hline    
    False positive          &   8                   &       NA                      &   NA              &   NA                  &   8      \\ \hline    
   \subcat{unused arguments}&   1                   &       NA                      &   NA              &   NA                  &   1      \\ \hline        
    \subcat{amendable}      &   4                   &       NA                      &   NA              &   NA                  &   4      \\ \hline            
 \subcat{built-in doc error}&   3                   &       NA                      &   NA              &   NA                  &   3      \\ \hline
    \textbf{Total} 
    (excl. false positives) &17                   &       NA                      &   NA              &   NA                  &   17      \\ \hline                
    \end{tabular}
\end{center}



\subsection{Selected Problems}

\subsubsection*{Actual Error When Handling \code{DOMElements}}

The error is related to the following code (shortened).

%pygmentize_begin php
% function assertEqualXMLStructure(
%   DOMElement $expectedElement/*, ...*/) {
%   ///...
%   PHPUnit_Util_XML::removeCharacterDataNodes($expectedElement);
%   PHPUnit_Util_XML::removeCharacterDataNodes($actualElement);
%   //...
%   for ($i = 0; $i < $expectedElement->childNodes->length; $i++) {
%       self::assertEqualXMLStructure(
%           $expectedElement->childNodes->item($i) /*<<< error */
%           /*...*/);
% }
%pygmentize_end
\begin{Verbatim}[commandchars=\\\{\}]
 \PY{k}{function} \PY{n+nf}{assertEqualXMLStructure}\PY{p}{(}
   \PY{n+nx}{DOMElement} \PY{n+nv}{\PYZdl{}expectedElement}\PY{c+cm}{/*, ...*/}\PY{p}{)} \PY{p}{\PYZob{}}
   \PY{c+c1}{///...}
   \PY{n+nx}{PHPUnit\PYZus{}Util\PYZus{}XML}\PY{o}{::}\PY{n+na}{removeCharacterDataNodes}\PY{p}{(}\PY{n+nv}{\PYZdl{}expectedElement}\PY{p}{);}
   \PY{n+nx}{PHPUnit\PYZus{}Util\PYZus{}XML}\PY{o}{::}\PY{n+na}{removeCharacterDataNodes}\PY{p}{(}\PY{n+nv}{\PYZdl{}actualElement}\PY{p}{);}
   \PY{c+c1}{//...}
   \PY{k}{for} \PY{p}{(}\PY{n+nv}{\PYZdl{}i} \PY{o}{=} \PY{l+m+mi}{0}\PY{p}{;} \PY{n+nv}{\PYZdl{}i} \PY{o}{\PYZlt{}} \PY{n+nv}{\PYZdl{}expectedElement}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n+na}{childNodes}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n+na}{length}\PY{p}{;} \PY{n+nv}{\PYZdl{}i}\PY{o}{++}\PY{p}{)} \PY{p}{\PYZob{}}
       \PY{n+nx}{self}\PY{o}{::}\PY{n+na}{assertEqualXMLStructure}\PY{p}{(}
           \PY{n+nv}{\PYZdl{}expectedElement}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n+na}{childNodes}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n+na}{item}\PY{p}{(}\PY{n+nv}{\PYZdl{}i}\PY{p}{)} \PY{c+cm}{/*\PYZlt{}\PYZlt{}\PYZlt{} error */}
           \PY{c+cm}{/*...*/}\PY{p}{);}
 \PY{p}{\PYZcb{}}
\end{Verbatim}

The method \code{assertEqualXMLStructure} accepts only instances 
of \code{DOMElement}, but it invokes itself recursively with first 
argument of type \code{DOMNode}. Because according to the 
PHP documentation the value of the \code{childNodes} property 
of interface \code{DOMNode} is an instance of \code{DOMNodeList} 
and the method \code{item(integer)} of \code{DOMNodeList} 
returns \code{DOMNode}, it is a type mismatch error as \code{DOMNode} 
is not subtype of \code{DOMElement}.

In the PHP implementation of DOM model, the only implementations of 
\code{DOMNode} either inherit from \code{DOMElement} or 
implement \code{DOMCharacterData}, and those are removed 
from the \code{childNodes} collection by \code{removeCharacterDataNodes}. 
Therefore, in most cases, this code behaves as expected. 

However, the \code{DOMNode} interface can be implemented by any user 
defined class, which does not have to inherit from 
\code{DOMElement}, and if an instance of such class was present 
in the \code{childNodes} collection, the code would cause an 
exception when trying to invoke \code{assertEqualXMLStructure} 
with an argument of wrong type.

Note that if method \code{removeCharacterDataNodes} removed 
all the child nodes that are not instances of \code{DOMElement}, 
the code would be correct, but the error would still be reported, 
therefore it would be false positive.


