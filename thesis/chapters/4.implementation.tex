\chapter{Implementation}

    \section{Implementation Specific Constraints}
    
    One of the requirements was that the project should be implemented 
    in the context of the Phalanger project. It should be ready 
    to be plugged in between the Phalanger's front-end and back-end and 
    it should also provide public interface useful for the 
    Phalanger PHP Visual Studio tools.
    
    \paragraph{Abstract Syntax Tree.} Phalanger front-end parses PHP code 
    into an Abstract Syntax Tree (AST) \cite{aho1985compilers} structure. 
    This structure is then traversed by the back-end using the 
    visitor design pattern \cite{gamma1994design}. Phalanger does not 
    use any other intermediate representation than AST and the 
    back end transforms the AST directly to Microsoft Intermediate Language (MSIL).
    
    In order to reduce the memory consumption and provide better 
    modularity, Phalanger code went through small architecture 
    refactoring before this project was started.     
    The classes representing the AST nodes originally contained 
    the code and data needed for emitting the corresponding 
    MSIL opcodes. This, however, represents 
    a coupling between the front-end and back-end and the 
    front-end cannot be used just on its own. In the new 
    version, the classes representing AST nodes are capable 
    of storing additional attributes in an extensible way 
    and the back-end have been rewritten to be an ordinary AST 
    visitor that uses the extensible AST nodes attributes.
    Additional attributes provide a way to annotate AST nodes 
    with any additional information, which in our case will be 
    the results of the analyses.    
    
    \paragraph{Integrated Development Environment Integration.}
    The PHP Tools for Visual Studio use Phalanger front-end in order to 
    parse PHP code into AST and then the AST is again traversed to provide 
    code completion and other features. All the AST nodes hold necessary 
    pieces of information, e.g. the position in the source file or 
    documentation comments.
    
    The aim of this project is to provide the results of type analysis 
    and other analyses to the integrated development environment so 
    that the possible errors and warnings can be visualised, e.g. underlined.
    
    The longer term aim of this project, not in the scope of this thesis, 
    is to replace the existing algorithms for code completion, 
    ``jump to definition'' and ``find usages'' features. Because 
    with a dynamic language like PHP, it is not trivial to 
    find all the usages of, for example, a class or determine 
    a definition of, for instance, a field accessed on some local variable. 
    In order to provide more precise results, 
    type analysis is needed.
    
    One of the challenging parts of integrated development 
    environment integration is also dealing with incomplete code 
    that is being typed in by the user. Therefore one of the requirements 
    was also that the analysis should be capable of 
    performing an ad-hoc re-analysis of once analysed 
    code with a new statement added. This ad-hoc re-analysis 
    should be, if possible, more effective that doing the 
    whole analysis again.
    
    \section{Overall Design}
    
    The project is divided into several modules.
    \begin{itemize}
        \item Control Flow Graph,
        \item Intermediate Representation of PHP Code (Phil, RPhil),
        \item Generic Data Flow Analysis Framework, 
        \item Tables with Type and Other Information, 
        \item Concrete Analyses:
        \begin{itemize}
            \item Dead Code Elimination, 
            \item Aliasing Analysis, 
            \item Constant Propagation,
            \item Type Analysis.
        \end{itemize}
    \end{itemize}
    
    The interactions between those modules on a conceptual level 
    when performing an analysis are depicted in diagram \ref{overalldiagram}. 
    Green elements represent extension points. Red arrows represent the 
    core flow of the algorithm.
    
\begin{figure}[h]  
  \centering
    \includegraphics*[width=\textwidth,height=\textheight,keepaspectratio,viewport=0 55 532 590]{img/ControlFlowModules.pdf}  
    \caption{Control Flow for Phalanger Design Overview\label{overalldiagram}}
\end{figure}    

    \subparagraph*{Intermediate Language.}
    One of the goals of the design was to stay as close as possible 
    to the original AST representation, so that the results of the 
    analysis can be easily propagated to an IDE and that the 
    Phalanger back-end does not have to be rewritten in order to 
    leverage the this project.
    
    Control Flow for Phalanger uses two intermediate representations 
    on a conceptual level, however, they are usually not explicitly 
    constructed as described later in the text. The purpose of the 
    intermediate representations is to simplify the design of the 
    analyses.
    
    \emph{Phil} stands for \emph{PHP Intermediate Language} and is very abstract 
    representations close to the original AST. Phil contains 
    only statements and expressions that can be in a Basic Block, 
    therefore it does not contain most of the control flow 
    changing statements like if, switch, or loops. 
    A Phil statement represents the smallest single step 
    of an execution that can change state of variables 
    or global state or throw an exception. Syntactic 
    constructs like \code{\$i++} are unfolded to 
    \code{\$i = \$i + 1}, which is then split to 
    evaluation of binary expression and assignment expression 
    that uses the result of the binary expression. In some sense, 
    Phil can be viewed as a three address code.
    
    \emph{RPhil} stands for \emph{Resolved PHP Intermediate Language}. 
    RPhil is basically a Phil with resolved symbols where possible. 
    By resolved symbols, we mean references to the elements 
    of Type Tables discussed in one of the following paragraphs. 
    In order to resolve the symbols, the module building RPhil 
    can use names explicitly expressed in the code, for example, 
    for direct local variable access \code{\$a}, or the results of 
    an analysis, for instance, the results of type analysis to 
    resolve method calls and fields references. 
    RPhil itself is typically consumed by the analyses, 
    so the accuracy of RPhil and subsequently of the 
    analyses results can be improved by iterative execution 
    of the analyses.
    
    \subparagraph*{Analyses.}
    The Data Flow Analysis is performed on Control Flow Graph 
    nodes called basic blocks. Each basic block contains 
    a list of Abstract Syntax Tree elements. This list is 
    then, usually on the fly, transformed to corresponding PHP 
    Intermediate Language elements before its elements are given 
    to the flow function of a concrete Data Flow Analysis 
    implementation. 
    
    Basic block can also contain already transformed PHP 
    Intermediate Language elements. However, the interface 
    does not change from the point of view of a concrete 
    Data Flow Analysis implementation.
    
    The Control Flow for Phalanger also contains and allows to 
    plug-in simple analyses that are performed for all 
    basic blocks sequentially without taking the control 
    flow into account. Each basic block is then analysed 
    only once. An example of such analysis is Aliasing Analysis.
    
    The last analysis type, which stands aside, is Dead Code 
    Elimination. It is performed on the Control Flow Graph, 
    but traverses it on its own as opposed to a concrete 
    Data Flow Analysis that only visits basic blocks 
    in order determined by the Data Flow Framework, 
    i.e. does not perform the graph traversal 
    on its own. Control Flow for Phalanger also allows 
    to add custom analyses that are performed on the raw 
    Control Flow Graph.
    
    \subparagraph*{Analyses Results.}
    The results of an analysis can be annotations added 
    to the AST node objects, or annotations of basic blocks, 
    which support extensible attributes in the same way as 
    AST nodes.
    
    The results of an analysis can also be pushed into 
    the Code Tables. Code Tables gather relevant information 
    about code elements like classes, functions, etc. 
    It is mainly type related information, 
    for example, a return type of a function, 
    but also which parameters are passed by reference or 
    whether the function returns a reference.
    
    \subparagraph*{Type Tables.} This module provides 
    almost the same information about routines, types, 
    global variables and constants as Code Tables. 
    However, in this case the information 
    is abstract, because it might not be directly related 
    to an actual element that can be found in the source code. 
    This is the case of library functions and classes, 
    but it also gives a possibility to merge the information 
    of two or more conditionally declared elements. 
    
    Although this kind of support for conditional declarations 
    has not been implemented, the design is prepared for it, 
    shall it be considered an important feature in the future. 
    At the moment, if two or more declarations are found, 
    the Type Tables behave as if they did not know the 
    element at all, which preserves correctness for the 
    price of loosing precision.
    
    \subparagraph*{Extensibility.}
    The whole project is designed as a class library and 
    framework with many extension points. Some of the 
    functionality can be used independently. For example, 
    Control Flow Graph builder to generate diagrams.
    
    Nonetheless, in order to provide better usability, 
    Control Flow for Phalanger also contains 
    a Facade class \code{AnalysisDriver} 
    that plugs in together all the necessary objects 
    and provides a simple interface to perform a defined 
    analysis of a file or a given piece of code.
    
    \section{The Intermediate Language}    
        \note{The aim of the intermediate representation is... 
        The three address code can be built by traversing the AST in 
        the order of execution... Some AST elements represent more 
        than one execution step...}
        
        \note{RPhil: the symbols are resolved using defined AST 
        nodes annotations for constant values and type information...
        \code{VarLikeConstructInfo} abstracts variables accesses...}
    
    \section{Control Flow Graph}
        \note{Description of the Control Flow graph construction}.
        
    \section{Data Flow Analysis}
        \note{Architecture of the generic algorithm implementation 
            using generics in C\# in a way that the graph the analysis 
            can be performed upon an arbitrary graph (not only CFG), 
            which can be useful if in the future some of the analyses 
            will be performed, for example, on a definition-use graph.}
        
    \section{Tables}
        \note{Intra-procedural dependencies handling \code{DependencyResolver}.}
    
    \section{Analyses}
        \subsection{Dead Code Elimination}
        \subsection{Aliasing Analysis}        
        \subsection{Constant Propagation}

    \section{Type Analysis}
        \note{
        \begin{itemize}
            \item Type Information representation
            \item Data Flow representation
            \item AST annotations
        \end{itemize}}

    \section{The Analyser pipeline and AnalysisDriver}
        \note{Description of the high level public interface 
        and the phases of the full analysis process.}