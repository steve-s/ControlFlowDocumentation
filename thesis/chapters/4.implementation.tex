\chapter{Implementation}

    \section{Implementation Specific Constraints}
    
    One of the requirements was that the project should be implemented 
    in the context of the Phalanger project. It should be ready 
    to be plugged in between the Phalanger's front-end and back-end and 
    it should also provide public interface useful for the 
    Phalanger PHP Visual Studio tools.
    
    \paragraph{Abstract Syntax Tree.} Phalanger front-end parses PHP code 
    into an Abstract Syntax Tree (AST) \cite{aho1985compilers} structure. 
    This structure is then traversed by the back-end using the 
    visitor design pattern \cite{gamma1994design}. Phalanger does not 
    use any other intermediate representation than AST.
    
    In order to reduce the memory consumption and provide better 
    modularity, Phalanger code went through small architecture 
    refactoring before this project was started.     
    The classes representing the AST nodes originally contained 
    the code and data needed for emitting the corresponding 
    Microsoft Intermediate Language opcodes. This, however, represents 
    a coupling between the front-end and back-end and the 
    front-end cannot be used just on its own. In the new 
    version, the classes representing AST nodes are capable 
    of storing additional attributes in an extensible way 
    and the back-end have been rewritten to be an ordinary AST 
    visitor that uses the extensible AST nodes attributes.
    Additional attributes provide a way to annotate AST nodes 
    with any additional information, which in our case will be 
    the results of the analyses.    
    
    \paragraph{Integrated Development Environment Integration.}
    The PHP Tools for Visual Studio use Phalanger front-end in order to 
    parse PHP code into AST and then the AST is again traversed to provide 
    code completion and other features. All the AST nodes hold necessary 
    pieces of information, e.g. the position in the source file or 
    documentation comments.
    
    The aim of this project is to provide the results of type analysis 
    and other analyses to the integrated development environment so 
    that the possible errors and warnings can be visualised, e.g. underlined.
    
    The longer term aim of this project, not in the scope of this thesis, 
    is to replace the existing algorithms for code completion, 
    ``jump to definition'' and ``find usages'' features. Because 
    with a dynamic language like PHP, it is not trivial to 
    find all the usages of e.g. a class or determine 
    a definition of e.g. a field accessed on some local variable. 
    In order to provide more precise results, 
    type analysis is needed.
    
    One of the challenging parts of integrated development 
    environment integration is also dealing with incomplete code 
    that is being typed in by the user. Therefore one of the requirements 
    was also that the analysis should be capable of 
    performing an ad-hoc re-analysis of once analysed 
    code with a new statement added. This ad-hoc re-analysis 
    should be, if possible, more effective that doing the 
    whole analysis again.
    
    \section{Overall Design}
    The project can be divided into several parts:
    \begin{itemize}
        \item Control Flow Graph construction,
        \item Data Flow Analysis framework, 
        \item Code Tables maintenance, 
        \item The analyses:
        \begin{itemize}
            \item Dead Code Elimination, 
            \item Aliasing Analysis, 
            \item Constant Propagation,
            \item Type Analysis.
        \end{itemize}
    \end{itemize}
    
    The Data Flow Analysis is performed on a Control Flow Graph. 
    However, the Data Flow Analysis is an abstract algorithm and 
    in order to implement a concrete Data Flow Analysis, 
    one must provide implementation of required missing operations. 
    
    An analysis is a concrete Data Flow Analysis or any 
    other analysis, because the analysis can be 
    performed, for example, only on the Control Flow Graph 
    (Dead Code Elimination) 
    or only on the function body (Aliasing Analysis) 
    without using the Data Flow Analysis algorithm. 
    The results of an analysis can be annotations added 
    into the AST node objects, or annotations of the Control Flow Graph 
    nodes, which support extensible attributes the way AST nodes do. 
    
    The results of an analysis can also be pushed into 
    the Code Tables. Code Tables gather relevant information about 
    code elements like classes, functions and others. 
    This information is mainly type related information, 
    for example, a return type of a function. Code Tables can 
    be also queried by an analysis, for example, when 
    the Type Analysis reaches a function call and needs to 
    find out what types the given function may return.
    
    The whole project is designed as a class library with 
    many extension points where some of the functionality 
    can be used independently. 
    However, in order to provide better usability, 
    it also contains a Facade class \code{AnalysisDriver} 
    that plugs in together all the necessary objects 
    and provides a simple interface to perform a defined 
    analysis of a file or a given piece of code.    
    
    \section{Control Flow Graph}
        \note{Description of the Control Flow graph construction. 
            Discussion of the choice of intermediate representation: 
            in fact, why we do not use any intermediate representation, 
            because we wanted to keep simple correspondence between 
            the AST nodes and analyses results and because the 
            back-end emits MSIL code from AST nodes}.
        
    \section{Data Flow Analysis}
        \note{Architecture of the generic algorithm implementation 
            using generics in C\# in a way that the graph the analysis 
            is performed upon can be arbitrary graph (not only CFG), 
            which can be useful if in the future some of the analyses 
            will be performed, for example, on a definition-use graph.}
        
    \section{Tables}
        \note{Intra-procedural dependencies handling.}
    
    \section{Aliasing and Constant Propagation Analysis}   
    
    \section{Type Analysis}
        \note{
        \begin{itemize}
            \item Type Information representation
            \item Data Flow representation
            \item AST annotations
        \end{itemize}}

    \section{The Analyser pipeline and AnalysisDriver}
        \note{Description of the high level public interface 
        and the phases of the full analysis process.}