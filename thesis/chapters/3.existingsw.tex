\chapter{Related Work}

    A brief overview of the static analysis methods was presented 
    in the previous \wchapter{}. In this \wchapter{}, we focus on 
    tools that also use static analysis to analyse PHP code for 
    different purposes. We also shortly mention interesting tools 
    for other dynamic languages.

    \section{Security Vulnerabilities in Web Applications}
    
    Most of the existing work on static analysis of PHP is 
    focused on discovery of security vulnerabilities in 
    web applications that typically come from improperly 
    handled user input, also called taint-style vulnerabilities. 
    It is important for such analyses to be able to follow 
    the flow of data from global variables like \code{\$\_POST} 
    that contain user input, therefore more precise model of 
    heap memory is required so that flow of data in between 
    object instances and routine calls can be analysed. 
    
    An analysis for security vulnerabilities has also a different 
    model of usage. Such analysis can be run less frequently, 
    for example, only before release or as a part of a continuous 
    build process. Interactive on-the-fly analysis in an 
    integrated development environment could also be a viable 
    use case, but typically not the main goal. Moreover, 
    such analysis is not likely to be run every time the 
    application is to be compiled or interpreted.
    
    Some of the available tools for detecting taint-style 
    vulnerabilities in PHP are Pixy\cite{jovanovic2006pixy} 
    and recently released Weverca: Web Verification Tool\cite{hauzarhunting}.
    
    \subsection{Weverca: Web Verification Tool}
    
    Weverca is an implementation of static analysis framework also 
    based on the Phalanger parser. As opposed to Control Flow for 
    Phalanger, the main goal of Weverca is to provide security 
    vulnerabilities analysis, although it is capable of supporting 
    other kinds of static analyses.
    
    \subsubsection*{Memory Abstraction}
    Weverca represents the program state at each program point by 
    an abstraction of the complete memory state including local 
    variables, global variables and static fields. Compared 
    to our approach, we represent the program state by the state 
    of local variables only and global variables and fields not 
    analysed precisely in context sensitive way, but summarized 
    in one global database shared among all analysed functions.
    
    The approach of Weverca enables better precision and 
    their default implementations of the memory model do 
    provide such precision. On the contrary, our approach 
    permits more effective representation of the program 
    points state. Needless to say, both tools provide means 
    to be extended with an implementation of the other 
    approach.
        
    Moreover, the memory abstraction used in Weverca includes 
    defined symbols, such as routines, classes and others. 
    PHP permits to define symbols dynamically and in certain circumstances 
    symbol cannot be used before it is defined\footnote{A symbol 
    cannot be used before the file with its declaration is imported, 
    but symbols from the same file can be used before they are declared.}. 
    Therefore Weverca is capable of discovering use before 
    declaration kind of errors for global symbols. In Control 
    Flow for Phalanger, we decided to not support this, 
    because most of the modern object oriented PHP projects 
    use \emph{autoloading} and with 
    autoloading it is impossible in general to analyse which 
    files are being imported at which program points. 
    Autoloading rules are often simple and follow 
    similar patterns and so a viable possibility for a static 
    analyser would be to let the user choose from predefined 
    set of autoloading rules that the analyser understands. 
    However, neither of the tools implement this feature yet.
    
    \subsubsection*{Intraprocedural Analysis}
    
    In order to make the interprocedural analysis context 
    sensitive, Weverca inlines the control flow graph of 
    invoked routine in the control flow graph of the 
    analysed routine. Note that there can be more than 
    one routine that can be invoked due to polymorphism 
    or dynamic nature of PHP. In such case Weverca 
    inlines all of them adding a non-deterministic choice 
    between them, in other words, edges from the routine call 
    program point to the first program point of all the 
    possible routines.
    
    As discussed in the previous \wchapter{}, Control Flow for 
    Phalanger uses modular approach, which may scale better, 
    but lacks the precision of Weverca.
    
    \subsubsection*{Type Information}
    
    \note{Support for type hints. Enough for whole subsubsection?}
    
    \subsubsection*{Design and Implementation}
    
    From the point of view of implementation, Weverca uses 
    Phalanger as a parser, but the design does not evince 
    any intention of tighter integration with Phalanger. 
    The version of Phalanger used is slightly outdated, 
    and thereof support for newer PHP language constructs 
    is probably missing.
    
    \note{PHPDoc support.}
    
    \note{Intermediate Representation}
    

    \section{Type Inference}
    
    Type inference for dynamic languages is typically implemented 
    for the purposes of compilation or interpretation. A notable implementation 
    is type inference for PHP in Facebook's Hip Hop project \cite{zhao2012hiphop}, 
    which is a compiler from PHP to C++ and a custom intermediate language 
    that can be run in the Hip Hop virtual machine. Hip Hop performs type 
    analysis in order to find a single type for a variable, so it can treat 
    it as statically typed variable during compilation. However, if a single 
    type for a variable cannot be determined, Hip Hop does not analyse 
    the type information any further and fall backs to the dynamic typing.    
        
    There are implementations of type inference for other dynamic languages. 
    Ecstatic\cite{madsen2007ecstatic} is type inference for Ruby 
    implemented using control flow insensitive cartesian product algorithm. 
    Rubydust\cite{an2011dynamic} introduces a \emph{constraint based dynamic 
    type inference} that infers static types based on dynamic program 
    executions.

    \subsection{Phantm}
    
    Phantm\cite{kneuss2010phantm} is a tool for detection of type related 
    errors. From all the projects mentioned in this chapter, the aim of 
    Phantm is closest to our project, which is why we also used Phantm 
    for evaluation and compared its results with ours in 
    section \ref{phantmresults} Comparison to Phantm.
    
    Phantm uses semi-dynamic and semi-static analysis approach. The web 
    application in question is run up to a defined point, which is invocation 
    of special Phantm's function that collects data about the state of the application, 
    especially, values of global variables. This data is then used as an initial 
    state for static analysis. The dynamic part of the analysis is called bootstrapping. 
    This design illustrates that although type related errors can be searched for 
    in generic frameworks, libraries or, for example, command line utilities 
    written in PHP, Phantm's focus is on complete web applications.
    
    \note{
    \begin{itemize*}
        \item similar type abstraction (null, false, true, int values are repr. explicitly for const. prop.)
        \item heap abstraction, but assumption about routines only changing a 
        local region in heap and returning fresh instances.
        \item array support: merging, termination -- limited nesting.
        \item ignores completely:
            \begin{itemize*}
                \item references
                \item indirect accessed (variables, fields)
                \item assignment in conditional exprs.
                \item eval, autoload
            \end{itemize*}
    \end{itemize*}    
    }
