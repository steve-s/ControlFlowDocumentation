\chapter{Related Work}

    Static analysis is a topic that is being actively researched. 
    A brief overview of the static analysis methods was presented 
    in the previous \wchapter{}. Control Flow for Phalanger's aim is 
    to adapt and apply some of the results of the research deemed 
    to be useful for the purposes of type analysis of PHP. 
    In related work, we focus on tools that also use static 
    analysis to analyse PHP code for different purposes. 
    We also shortly mention interesting tools for other 
    dynamic languages.

    \section{Security Vulnerabilities in Web Applications}
    
    Most of the existing work on static analysis of PHP is 
    focused on discovery of security vulnerabilities in 
    web applications that typically come from improperly 
    handled user input, also called taint-style vulnerabilities. 
    It is important for such analyses to be able to follow 
    the flow of data from global variables like \code{\$\_POST} 
    that contain user input, therefore more precise model of 
    heap memory is required so that flow of data in between 
    object instances and routine calls can be analysed. 
    
    An analysis for security vulnerabilities has also a different 
    model of usage. Such analysis can be run not so frequently, 
    for example, only before release or as a part of a continuous 
    build process. Interactive on-the-fly analysis in an 
    integrated development environment could also be a viable 
    use case, but typically not the main goal. Moreover, 
    such analysis is not likely to be run every time the 
    application is to be compiled or interpreted.
    
    Some of the available tools for detecting taint-style 
    vulnerabilities in PHP are Pixy\cite{jovanovic2006pixy} 
    and recently released Weverca: Web Verification Tool\cite{hauzarhunting}.    
    
    \subsection{Weverca: Web Verification Tool}
    
    Weverca is also based on the Phalanger parser, but it uses an older 
    version, therefore it does not support some of the newer language 
    constructs.
    
    Opposed to our modular approach, Weverca uses heap abstractions, 
    which in correspondence with the different goals of both projects 
    where Weverca focuses on tracking data that originated from user 
    input down to their usage.
    
    In order to make the interprocedural analysis context sensitive, 
    Weverca uses routines inlining: the whole routines body is 
    copied at the place of its invocation and formal parameters 
    are substituted for the actual parameters of the routine 
    invocation.
    
    % TODO: what do they do if this cannot be done?

    \section{Type Inference}
    
    Type inference for dynamic languages is typically implemented 
    for the purposes of compilation or interpretation. A notable implementation 
    is type inference for PHP in Facebook's Hip Hop project \cite{zhao2012hiphop}, 
    which is a compiler from PHP to C++ and a custom intermediate language 
    that can be run in the Hip Hop virtual machine. Hip Hop performs type 
    analysis in order to find a single type for a variable, so it can treat 
    it as statically typed variable during compilation. However, if a single 
    type for a variable cannot be determined, Hip Hop does not analyse 
    the type information any further and fall backs to the dynamic typing.    
        
    There are implementations of type inference for other dynamic languages. 
    Ecstatic\cite{madsen2007ecstatic} is type inference for Ruby 
    implemented using control flow insensitive cartesian product algorithm. 
    Rubydust\cite{an2011dynamic} introduces a \emph{constraint based dynamic 
    type inference} that infers static types based on dynamic program 
    executions.

    \subsection{Phantm}
    
    Phantm\cite{kneuss2010phantm} is a tool for detection of type related 
    errors. From all the projects mentioned in this chapter, the aim of 
    Phantm is closest to our project, which is why we also used Phantm 
    for evaluation and compared its results with ours in 
    section \ref{phantmresults} Comparison to Phantm.
    
    Phantm uses semi-dynamic and semi-static analysis approach. The web 
    application in question is run up to a defined point, which is invocation 
    of special Phantm's function that collects data about the state of the application, 
    especially, values of global variables. This data is then used as an initial 
    state for static analysis. The dynamic part of the analysis is called bootstrapping. 
    This design illustrates that although type related errors can be searched for 
    in generic frameworks, libraries or, for example, command line utilities 
    written in PHP, Phantm's focus is on complete web applications.
    
    %\note{Precise memory model, Routines inlining, ...}

    
    
    
    
    
    
